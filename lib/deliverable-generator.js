/**
 * Deliverable Generator
 * Generates BMAD deliverables (PRD, architecture, stories) from agent outputs
 */

const fs = require('fs-extra');
const path = require('node:path');
const { BMADBridge } = require('./bmad-bridge');

class DeliverableGenerator {
  constructor(projectPath = process.cwd(), options = {}) {
    this.projectPath = projectPath;
    this.docsPath = path.join(projectPath, 'docs');
    this.bmadBridge = options.bmadBridge || new BMADBridge();
  }

  /**
   * Initialize deliverable generator
   */
  async initialize() {
    await this.bmadBridge.initialize();
    await fs.ensureDir(this.docsPath);
  }

  /**
   * Generate project brief (analyst phase)
   */
  async generateBrief(context) {
    const briefContent = this.formatBrief(context);
    const briefPath = path.join(this.docsPath, 'brief.md');

    await fs.writeFile(briefPath, briefContent, 'utf8');

    return {
      type: 'brief',
      path: briefPath,
      content: briefContent,
    };
  }

  /**
   * Generate Product Requirements Document (PM phase)
   */
  async generatePRD(context) {
    const prdContent = this.formatPRD(context);
    const prdPath = path.join(this.docsPath, 'prd.md');

    await fs.writeFile(prdPath, prdContent, 'utf8');

    return {
      type: 'prd',
      path: prdPath,
      content: prdContent,
    };
  }

  /**
   * Generate Architecture Document (architect phase)
   */
  async generateArchitecture(context) {
    const archContent = this.formatArchitecture(context);
    const archPath = path.join(this.docsPath, 'architecture.md');

    await fs.writeFile(archPath, archContent, 'utf8');

    // Also generate architecture shards if needed
    await this.generateArchitectureShards(context);

    return {
      type: 'architecture',
      path: archPath,
      content: archContent,
    };
  }

  /**
   * Generate architecture shards
   */
  async generateArchitectureShards(context) {
    const archDir = path.join(this.docsPath, 'architecture');
    await fs.ensureDir(archDir);

    // Coding standards
    if (context.codingStandards) {
      await fs.writeFile(
        path.join(archDir, 'coding-standards.md'),
        this.formatCodingStandards(context.codingStandards),
        'utf8',
      );
    }

    // Tech stack
    if (context.techStack) {
      await fs.writeFile(
        path.join(archDir, 'tech-stack.md'),
        this.formatTechStack(context.techStack),
        'utf8',
      );
    }

    // Source tree
    if (context.sourceTree) {
      await fs.writeFile(
        path.join(archDir, 'source-tree.md'),
        this.formatSourceTree(context.sourceTree),
        'utf8',
      );
    }
  }

  /**
   * Generate Epic (SM phase)
   */
  async generateEpic(epicData) {
    const epicsDir = path.join(this.docsPath, 'epics');
    await fs.ensureDir(epicsDir);

    const epicContent = this.formatEpic(epicData);
    const epicPath = path.join(
      epicsDir,
      `epic-${epicData.number}-${this.slugify(epicData.title)}.md`,
    );

    await fs.writeFile(epicPath, epicContent, 'utf8');

    return {
      type: 'epic',
      path: epicPath,
      content: epicContent,
      number: epicData.number,
    };
  }

  /**
   * Generate User Story (SM phase)
   */
  async generateStory(storyData) {
    const storiesDir = path.join(this.docsPath, 'stories');
    await fs.ensureDir(storiesDir);

    const storyContent = this.formatStory(storyData);
    const storyPath = path.join(
      storiesDir,
      `story-${storyData.epicNumber}-${storyData.storyNumber}-${this.slugify(storyData.title)}.md`,
    );

    await fs.writeFile(storyPath, storyContent, 'utf8');

    return {
      type: 'story',
      path: storyPath,
      content: storyContent,
      epicNumber: storyData.epicNumber,
      storyNumber: storyData.storyNumber,
    };
  }

  /**
   * Generate QA Assessment
   */
  async generateQAAssessment(context) {
    const qaDir = path.join(this.docsPath, 'qa', 'assessments');
    await fs.ensureDir(qaDir);

    const assessmentContent = this.formatQAAssessment(context);
    const assessmentPath = path.join(qaDir, 'risk-assessment.md');

    await fs.writeFile(assessmentPath, assessmentContent, 'utf8');

    return {
      type: 'qa_assessment',
      path: assessmentPath,
      content: assessmentContent,
    };
  }

  /**
   * Format brief document
   */
  formatBrief(context) {
    return `# Project Brief

## Problem Statement
${context.problemStatement || 'TBD'}

## Target Users
${context.targetUsers || 'TBD'}

## Goals & Objectives
${context.goals || 'TBD'}

## Success Criteria
${context.successCriteria || 'TBD'}

## Constraints
${context.constraints || 'TBD'}

## Market Context
${context.marketContext || 'TBD'}

## Competitive Landscape
${context.competitive || 'TBD'}

## Next Steps
${context.nextSteps || 'Proceed to Product Requirements phase'}

---
*Generated by BMAD-invisible*
`;
  }

  /**
   * Format PRD document
   */
  formatPRD(context) {
    return `# Product Requirements Document

## Executive Summary
${context.executiveSummary || 'TBD'}

## Goals & Objectives
${context.goals || 'TBD'}

## User Personas
${context.personas || 'TBD'}

## Features & Requirements

### Must-Have Features
${this.formatFeatureList(context.mustHave || [])}

### Should-Have Features
${this.formatFeatureList(context.shouldHave || [])}

### Could-Have Features
${this.formatFeatureList(context.couldHave || [])}

## User Stories & Epics
${this.formatEpicsList(context.epics || [])}

## Non-Functional Requirements
${context.nonFunctional || 'TBD'}

## Acceptance Criteria
${context.acceptanceCriteria || 'TBD'}

## Timeline & Milestones
${this.formatTimeline(context.timeline || {})}

## Dependencies & Risks
${context.dependencies || 'TBD'}

---
*Generated by BMAD-invisible*
`;
  }

  /**
   * Format architecture document
   */
  formatArchitecture(context) {
    return `# System Architecture

## Technology Stack
${this.formatTechStack(context.techStack || {})}

## System Components
${context.components || 'TBD'}

## Data Architecture
${context.dataArchitecture || 'TBD'}

## API Design
${context.apiDesign || 'TBD'}

## Security Architecture
${context.security || 'TBD'}

## Deployment Architecture
${context.deployment || 'TBD'}

## Scalability & Performance
${context.scalability || 'TBD'}

## Integration Points
${context.integrations || 'TBD'}

---
*Generated by BMAD-invisible*
`;
  }

  /**
   * Format epic document
   */
  formatEpic(epicData) {
    return `# Epic ${epicData.number}: ${epicData.title}

## Description
${epicData.description || 'TBD'}

## Goals
${epicData.goals || 'TBD'}

## User Stories
${this.formatStoriesList(epicData.stories || [])}

## Acceptance Criteria
${this.formatCriteriaList(epicData.acceptanceCriteria || [])}

## Dependencies
${epicData.dependencies || 'None'}

## Estimated Effort
${epicData.effort || 'TBD'}

---
*Generated by BMAD-invisible*
`;
  }

  /**
   * Format user story document
   */
  formatStory(storyData) {
    return `# Story ${storyData.epicNumber}.${storyData.storyNumber}: ${storyData.title}

## User Story
As a ${storyData.userRole || 'user'}
I want to ${storyData.action || 'TBD'}
So that ${storyData.benefit || 'TBD'}

## Description
${storyData.description || 'TBD'}

## Acceptance Criteria
${this.formatCriteriaList(storyData.acceptanceCriteria || [])}

## Technical Details
${storyData.technicalDetails || 'TBD'}

## Implementation Notes
${storyData.implementationNotes || 'TBD'}

## Testing Strategy
${storyData.testingStrategy || 'TBD'}

## Definition of Done
${this.formatCriteriaList(storyData.definitionOfDone || [])}

---
*Generated by BMAD-invisible*
`;
  }

  /**
   * Format QA assessment
   */
  formatQAAssessment(context) {
    return `# QA Risk Assessment

## Test Strategy
${context.testStrategy || 'TBD'}

## Risk Analysis
${context.riskAnalysis || 'TBD'}

## Test Coverage Requirements
${context.testCoverage || 'TBD'}

## Quality Gates
${this.formatCriteriaList(context.qualityGates || [])}

---
*Generated by BMAD-invisible*
`;
  }

  // Helper formatting methods

  formatFeatureList(features) {
    if (features.length === 0) return '- TBD';
    return features.map((f) => `- ${f}`).join('\n');
  }

  formatEpicsList(epics) {
    if (epics.length === 0) return '- TBD';
    return epics
      .map((e, i) => `\n### Epic ${i + 1}: ${e.title || 'TBD'}\n${e.description || ''}`)
      .join('\n');
  }

  formatStoriesList(stories) {
    if (stories.length === 0) return '- TBD';
    return stories.map((s, i) => `- Story ${i + 1}: ${s.title || 'TBD'}`).join('\n');
  }

  formatCriteriaList(criteria) {
    if (criteria.length === 0) return '- TBD';
    return criteria.map((c) => `- [ ] ${c}`).join('\n');
  }

  formatTimeline(timeline) {
    if (!timeline.milestones) return 'TBD';
    return timeline.milestones
      .map((m) => `- **${m.name}** (${m.date}): ${m.description || ''}`)
      .join('\n');
  }

  formatTechStack(stack) {
    if (!stack || typeof stack !== 'object') return 'TBD';

    let output = '';
    for (const [category, technologies] of Object.entries(stack)) {
      output += `\n### ${category}\n`;
      if (Array.isArray(technologies)) {
        output += technologies.map((t) => `- ${t}`).join('\n');
      } else {
        output += `${technologies}`;
      }
      output += '\n';
    }
    return output;
  }

  formatCodingStandards(standards) {
    return `# Coding Standards

${standards}

---
*Generated by BMAD-invisible*
`;
  }

  formatSourceTree(tree) {
    return `# Source Tree Structure

\`\`\`
${tree}
\`\`\`

---
*Generated by BMAD-invisible*
`;
  }

  slugify(text) {
    return text
      .toLowerCase()
      .replaceAll(/[^\w\s-]/g, '')
      .replaceAll(/\s+/g, '-')
      .replaceAll(/--+/g, '-')
      .trim();
  }
}

module.exports = { DeliverableGenerator };
