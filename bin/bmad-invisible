#!/usr/bin/env node

/**
 * BMAD Invisible - Main CLI entry point for npx deployment
 *
 * This executable provides easy installation and setup via:
 *   npx bmad-invisible init
 *   npx bmad-invisible chat
 *   npx bmad-invisible install
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { runIntegrityPreflight } = require('../common/utils/integrity');

let command;
let args = [];
const packageRoot = path.join(__dirname, '..');

const CLAUDE_PROVIDER_ENV_KEYS = [
  'CLAUDE_CLI_PROVIDER',
  'CLAUDE_CLI_DEFAULT_PROVIDER',
  'CLAUDE_DEFAULT_PROVIDER',
  'CLAUDE_PROVIDER',
  'CLAUDE_CODE_PROVIDER',
];

const parseEnvFile = (filePath) => {
  const parsed = {};
  const raw = fs.readFileSync(filePath, 'utf8');
  const lines = raw.split(/\r?\n/);

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }

    const equalsIndex = trimmed.indexOf('=');
    if (equalsIndex === -1) {
      continue;
    }

    let key = trimmed.slice(0, equalsIndex).trim();
    if (key.startsWith('export ')) {
      key = key.slice('export '.length).trim();
    }

    if (!key) {
      continue;
    }

    let value = trimmed.slice(equalsIndex + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }

    parsed[key] = value;
  }

  return parsed;
};

const readProjectEnv = (projectRoot) => {
  const envPath = path.join(projectRoot, '.env');
  if (!fs.existsSync(envPath)) {
    return { values: {}, path: envPath };
  }

  try {
    return { values: parseEnvFile(envPath), path: envPath };
  } catch (error) {
    console.warn(
      `⚠️ Unable to parse ${envPath}: ${error.message || error}. Continuing without it.`,
    );
    return { values: {}, path: envPath };
  }
};

const isInteractiveTerminal = () => Boolean(process.stdin.isTTY && process.stdout.isTTY);

const parseProviderFromArgs = (cliArgs = []) => {
  for (let index = 0; index < cliArgs.length; index += 1) {
    const arg = cliArgs[index];

    if (arg === '--provider') {
      const next = cliArgs[index + 1];
      if (typeof next === 'string' && next.trim()) {
        return next.trim().toLowerCase();
      }
      continue;
    }

    if (arg && typeof arg === 'string' && arg.startsWith('--provider=')) {
      const [, value] = arg.split('=');
      if (value && value.trim()) {
        return value.trim().toLowerCase();
      }
    }
  }

  return undefined;
};

const determineClaudeProvider = (cliArgs = [], envFromFile = {}) => {
  const fromArgs = parseProviderFromArgs(cliArgs);
  if (fromArgs) {
    return fromArgs;
  }

  for (const key of CLAUDE_PROVIDER_ENV_KEYS) {
    const value = process.env[key] || envFromFile[key];
    if (typeof value === 'string' && value.trim()) {
      return value.trim().toLowerCase();
    }
  }

  return undefined;
};

const promptForInput = (question) =>
  new Promise((resolve, reject) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    let cleanedUp = false;
    const cleanup = () => {
      if (cleanedUp) return;
      cleanedUp = true;
      try {
        rl.close();
      } catch {
        // Ignore cleanup errors
      }
    };

    rl.on('error', (error) => {
      cleanup();
      reject(error);
    });

    rl.question(question, (answer) => {
      cleanup();
      resolve(answer);
    });
  });

const promptForGlmCredentials = async ({ existingBaseUrl } = {}) => {
  console.log('🔐 GLM provider selected. A Z.AI API token is required.');

  let apiKey;
  while (!apiKey) {
    // eslint-disable-next-line no-await-in-loop
    const input = await promptForInput('Enter your Z.AI GLM API token: ');
    const trimmed = (input || '').trim();
    if (trimmed) {
      apiKey = trimmed;
    } else {
      console.log('⚠️ Token cannot be empty. Please provide a valid value.');
    }
  }

  const baseUrlPrompt = existingBaseUrl
    ? `Enter a custom GLM base URL (leave blank to keep ${existingBaseUrl}): `
    : 'Enter a custom GLM base URL (leave blank for the CLI default): ';
  const baseUrlInput = await promptForInput(baseUrlPrompt);
  const baseUrl = (baseUrlInput || '').trim();

  return { apiKey, baseUrl: baseUrl || undefined };
};

const promptToPersistGlmEnv = async () => {
  if (!isInteractiveTerminal()) {
    return false;
  }

  try {
    const answer = await promptForInput(
      'Would you like to save these GLM credentials to .env for future runs? (y/N): ',
    );
    const normalized = (answer || '').trim().toLowerCase();
    return normalized === 'y' || normalized === 'yes';
  } catch (error) {
    console.warn(
      `⚠️ Skipping persistence prompt due to an input error: ${error.message || error}`,
    );
    return false;
  }
};

const persistEnvValues = (envPath, updates) => {
  const normalizedUpdates = Object.entries(updates).reduce((acc, [key, value]) => {
    if (typeof value === 'string' && value) {
      acc[key] = value;
    }
    return acc;
  }, {});

  const updateKeys = Object.keys(normalizedUpdates);
  if (updateKeys.length === 0) {
    return;
  }

  let lines = [];
  if (fs.existsSync(envPath)) {
    lines = fs.readFileSync(envPath, 'utf8').split(/\r?\n/);
  }

  const seenKeys = new Set();
  const updatedLines = lines.map((line) => {
    const match = line.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=(.*)$/);
    if (!match) {
      return line;
    }

    const key = match[1];
    if (Object.prototype.hasOwnProperty.call(normalizedUpdates, key)) {
      seenKeys.add(key);
      return `${key}=${normalizedUpdates[key]}`;
    }

    return line;
  });

  for (const key of updateKeys) {
    if (!seenKeys.has(key)) {
      updatedLines.push(`${key}=${normalizedUpdates[key]}`);
    }
  }

  let finalContent = updatedLines.join('\n');
  if (finalContent && !finalContent.endsWith('\n')) {
    finalContent += '\n';
  }

  if (!finalContent) {
    finalContent = `${updateKeys.map((key) => `${key}=${normalizedUpdates[key]}`).join('\n')}\n`;
  }

  fs.writeFileSync(envPath, finalContent);
};

const ensureClaudeEnvironment = async ({ projectRoot, userArgs = [] }) => {
  const { values: fileEnv, path: envPath } = readProjectEnv(projectRoot);

  const anthropicToken = process.env.ANTHROPIC_AUTH_TOKEN || fileEnv.ANTHROPIC_AUTH_TOKEN;
  if (anthropicToken && !process.env.ANTHROPIC_AUTH_TOKEN) {
    process.env.ANTHROPIC_AUTH_TOKEN = anthropicToken;
  }

  const glmKeyFromProcess = process.env.GLM_API_KEY;
  const glmKeyFromFile = fileEnv.GLM_API_KEY;
  const glmBaseFromProcess = process.env.GLM_BASE_URL;
  const glmBaseFromFile = fileEnv.GLM_BASE_URL;

  if (!glmKeyFromProcess && glmKeyFromFile) {
    process.env.GLM_API_KEY = glmKeyFromFile;
  }

  if (!glmBaseFromProcess && glmBaseFromFile) {
    process.env.GLM_BASE_URL = glmBaseFromFile;
  }

  const provider = determineClaudeProvider(userArgs, fileEnv);
  if (provider !== 'glm') {
    return;
  }

  const effectiveBaseUrl = process.env.GLM_BASE_URL || glmBaseFromFile;

  if (process.env.GLM_API_KEY) {
    return;
  }

  if (!isInteractiveTerminal()) {
    console.error('❌ GLM provider selected but GLM_API_KEY is not set.');
    console.error(
      '   Provide GLM_API_KEY (and optional GLM_BASE_URL) via environment variables or a project .env file before running in non-interactive mode.',
    );
    process.exit(1);
    return;
  }

  let credentials;
  try {
    credentials = await promptForGlmCredentials({ existingBaseUrl: effectiveBaseUrl });
  } catch (error) {
    console.error('❌ Failed to read GLM credentials:', error.message || error);
    process.exit(1);
    return;
  }

  process.env.GLM_API_KEY = credentials.apiKey;
  if (credentials.baseUrl) {
    process.env.GLM_BASE_URL = credentials.baseUrl;
  } else if (effectiveBaseUrl) {
    process.env.GLM_BASE_URL = effectiveBaseUrl;
  }

  const shouldPersist = await promptToPersistGlmEnv();
  if (!shouldPersist) {
    console.log('ℹ️ Skipped saving GLM credentials to .env.');
    return;
  }

  const updates = { GLM_API_KEY: credentials.apiKey };
  const baseToPersist = credentials.baseUrl || effectiveBaseUrl;
  if (baseToPersist) {
    updates.GLM_BASE_URL = baseToPersist;
  }

  try {
    persistEnvValues(envPath, updates);
    const relativeEnvPath = path.relative(process.cwd(), envPath) || '.env';
    console.log(`💾 Saved GLM credentials to ${relativeEnvPath}`);
  } catch (error) {
    console.warn(`⚠️ Unable to persist GLM credentials: ${error.message || error}`);
  }
};

// Get current package version
const packageJsonPath = path.join(__dirname, '..', 'package.json');
const currentVersion = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')).version;

const printHelp = () => {
  console.log(`
BMAD Invisible - Zero-knowledge AI orchestration (v${currentVersion})

Usage:
  npx bmad-invisible@latest <command> [options]

Commands:

  start                🚀 ONE-COMMAND SETUP: init + install + prompt for assistant choice
  init                 Initialize BMAD-invisible in current project
  chat                 Start conversational interface with Claude CLI
  codex                Start conversational interface with Codex CLI
  opencode             Start conversational interface with OpenCode CLI

  install              Install BMAD-invisible globally
  build                Build MCP server
  test                 Run test suite
  validate             Validate configuration
  help                 Show this help message

Examples:

  npx bmad-invisible@latest start      # 🚀 Do everything in one command!
  npx bmad-invisible@latest start --assistant=opencode
                                      # Skip the prompt and launch OpenCode
  npx bmad-invisible@latest init       # Setup in current project
  npm run codex                        # Start conversation (after install)


💡 Tip: Always use @latest to get the newest version:
   npx bmad-invisible@latest start

For more information: https://github.com/bacoco/BMAD-invisible
`);
};

const ASSISTANT_CHOICES = ['claude', 'codex', 'opencode'];

const OPTIONAL_MCP_SERVERS = [
  {
    id: 'chrome-devtools',
    label: 'Chrome DevTools bridge',
    description: 'Inspect and control active Chrome tabs via the DevTools protocol.',
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-chrome-devtools'],
      disabled: false,
    },
  },
  {
    id: 'shadcn',
    label: 'shadcn/ui component generator',
    description: 'Generate UI components from the shadcn library.',
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-shadcn'],
      disabled: false,
    },
  },
];

const formatAssistantName = (value) =>
  value.charAt(0).toUpperCase() + value.slice(1);

const parseAssistantFromArgs = (currentArgs) => {
  let assistant;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--assistant') {
      assistant = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--assistant=')) {
      assistant = arg.split('=')[1];
      continue;
    }

    sanitized.push(arg);
  }

  return {
    assistant: assistant ? assistant.toLowerCase() : undefined,
    sanitized,
  };
};

const promptForAssistant = () =>
  new Promise((resolve, reject) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    // Ensure readline is cleaned up on error
    let cleanedUp = false;
    const cleanup = () => {
      if (cleanedUp) return;
      cleanedUp = true;
      try {
        rl.close();
      } catch {
        // Ignore cleanup errors
      }
    };

    rl.on('error', (error) => {
      cleanup();
      reject(error);
    });

    const options = ASSISTANT_CHOICES.map(formatAssistantName).join(' / ');

    rl.question(
      `Which assistant should we launch? (${options}): `,
      (answer) => {
        cleanup();
        const normalized = (answer || '').trim().toLowerCase();
        if (!normalized) {
          console.log('⚠️ No assistant selected. Please choose one.');
          return promptForAssistant().then(resolve).catch(reject);
        }

        if (ASSISTANT_CHOICES.includes(normalized)) {
          resolve(normalized);
          return;
        }

        console.log('⚠️ Unrecognized selection. Please try again.');
        return promptForAssistant().then(resolve).catch(reject);
      },
    );
  });

const determineAssistant = async (flagValue) => {
  if (flagValue) {
    if (ASSISTANT_CHOICES.includes(flagValue)) {
      return flagValue;
    }

    console.error('⚠️ Unsupported assistant flag value:', flagValue);
    console.error('Valid options:', ASSISTANT_CHOICES.join(', '));
    process.exit(1);
    return; // For testing when exit is mocked
  }

  if (!process.stdout.isTTY) {
    console.error(
      '⚠️ Non-interactive mode requires --assistant flag. Use: --assistant=claude|codex|opencode',
    );
    process.exit(1);
    return; // For testing when exit is mocked
  }

  return promptForAssistant();
};

// Command handlers
const commands = {
  start: async () => {
    console.log('🚀 Starting BMAD-invisible setup...\n');

    // Determine assistant preference before installation begins
    const { assistant: assistantFlag, sanitized } = parseAssistantFromArgs(args);
    args.splice(0, args.length, ...sanitized);
    const assistant = await determineAssistant(assistantFlag);

    // If assistant is undefined, exit was called (possibly mocked in tests)
    if (!assistant) {
      return;
    }

    if (process.stdout.isTTY) {
      console.log(
        '💡 We can optionally enable additional MCP servers (chrome-devtools, shadcn) during setup.',
      );
    }

    // Run init
    await commands.init();

    // Run npm install
    console.log('\n📦 Installing dependencies...\n');
    const install = spawn('npm', ['install'], {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: true,
    });

    await new Promise((resolve, reject) => {
      install.on('exit', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error('npm install failed'));
        }
      });
    });

    const assistantName = formatAssistantName(assistant);
    console.log(`\n🎯 Starting BMAD Invisible Orchestrator with ${assistantName}...\n`);

    if (assistant === 'claude') {
      await commands.chat();
      return;
    }

    if (assistant === 'opencode') {
      await commands.opencode();
      return;
    }

    await commands.codex();
  },

  init: async () => {
    console.log('🚀 Initializing BMAD-invisible...\n');

    const projectRoot = process.cwd();
    const packagePath = path.join(projectRoot, 'package.json');

    // Create package.json if it doesn't exist
    if (!fs.existsSync(packagePath)) {
      console.log('📦 Creating package.json...');
      const defaultPackage = {
        name: path.basename(projectRoot),
        version: '1.0.0',
        description: 'Project powered by BMAD-invisible',
        scripts: {},
        keywords: [],
        author: '',
        license: 'ISC',
      };
      fs.writeFileSync(packagePath, JSON.stringify(defaultPackage, null, 2) + '\n');
      console.log('✅ Created package.json');
    }

    // Create .bmad-invisible directory
    const bmadDir = path.join(projectRoot, '.bmad-invisible');
    if (!fs.existsSync(bmadDir)) {
      fs.mkdirSync(bmadDir, { recursive: true });
      console.log('✅ Created .bmad-invisible directory');
    }

    // Create .claude directory for MCP config
    const claudeDir = path.join(projectRoot, '.claude');
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
      console.log('✅ Created .claude directory');
    }

    // Create MCP config (inline template since we might be running from npx cache)
    const mcpConfigDest = path.join(claudeDir, 'mcp-config.json');
    let mcpConfig = { mcpServers: {} };
    let hadExistingMcpConfig = false;
    if (fs.existsSync(mcpConfigDest)) {
      try {
        const parsed = JSON.parse(fs.readFileSync(mcpConfigDest, 'utf8'));
        if (parsed && typeof parsed === 'object' && parsed.mcpServers) {
          // Preserve all top-level keys (logging, environment, etc.), not just mcpServers
          mcpConfig = { ...parsed };
          mcpConfig.mcpServers = { ...parsed.mcpServers };
          hadExistingMcpConfig = true;
        }
      } catch (error) {
        console.warn('⚠️ Failed to parse existing MCP configuration. Rebuilding from defaults.');
      }
    }

    const orchestratorKey = 'bmad-invisible-orchestrator';
    const orchestratorConfig = {
      command: 'node',
      args: ['${workspaceFolder}/node_modules/bmad-invisible/dist/mcp/mcp/server.js'],
      disabled: false,
    };

    if (!mcpConfig.mcpServers[orchestratorKey]) {
      mcpConfig.mcpServers[orchestratorKey] = orchestratorConfig;
      console.log('✅ Added BMAD-invisible orchestrator MCP server');
    } else {
      // Ensure orchestrator is enabled during re-init (user may have disabled it)
      mcpConfig.mcpServers[orchestratorKey].disabled = false;
    }

    const promptYesNo = async (question) => {
      if (!process.stdout.isTTY) {
        return false;
      }

      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        let cleanedUp = false;
        const cleanup = () => {
          if (cleanedUp) return;
          cleanedUp = true;
          try {
            rl.close();
          } catch {
            // ignore cleanup errors
          }
        };

        rl.on('error', (error) => {
          cleanup();
          reject(error);
        });

        rl.question(`${question} (y/N): `, (answer) => {
          cleanup();
          const normalized = (answer || '').trim().toLowerCase();
          resolve(normalized === 'y' || normalized === 'yes');
        });
      });
    };

    const optionalServerPromptsNeeded = OPTIONAL_MCP_SERVERS.filter(
      ({ id }) => !mcpConfig.mcpServers[id],
    );

    if (optionalServerPromptsNeeded.length > 0) {
      if (process.stdout.isTTY) {
        console.log('\n✨ Optional MCP servers available:');
        for (const server of optionalServerPromptsNeeded) {
          console.log(`   • ${server.label} — ${server.description}`);
        }
        console.log('');
      } else {
        console.log(
          'ℹ️ Optional MCP servers detected, but prompts are skipped in non-interactive mode.',
        );
      }
    }

    for (const optional of OPTIONAL_MCP_SERVERS) {
      if (mcpConfig.mcpServers[optional.id]) {
        continue;
      }

      let shouldAdd = false;
      try {
        shouldAdd = await promptYesNo(`Would you like to enable the ${optional.label}?`);
      } catch (error) {
        console.warn(
          `⚠️ Skipping ${optional.label} prompt due to an input error: ${error.message || error}`,
        );
      }

      if (shouldAdd) {
        mcpConfig.mcpServers[optional.id] = { ...optional.config };
        console.log(`✅ Added optional MCP server: ${optional.label}`);
      } else {
        console.log(`⏭️ Skipped optional MCP server: ${optional.label}`);
      }
    }

    fs.writeFileSync(mcpConfigDest, JSON.stringify(mcpConfig, null, 2) + '\n');
    console.log(
      hadExistingMcpConfig
        ? '✅ Updated MCP configuration with selected servers'
        : '✅ Created MCP configuration',
    );

    // Create docs directory
    const docsDir = path.join(projectRoot, 'docs');
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
      console.log('✅ Created docs directory');
    }

    // Add to package.json scripts
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    packageJson.scripts = packageJson.scripts || {};

    const scriptsToAdd = {
      codex: 'bmad-invisible codex',
      'bmad:codex': 'bmad-invisible codex',
      'bmad:chat': 'bmad-invisible chat',
      'bmad:build': 'bmad-invisible build',
    };

    let scriptsAdded = false;
    for (const [key, value] of Object.entries(scriptsToAdd)) {
      if (!packageJson.scripts[key]) {
        packageJson.scripts[key] = value;
        scriptsAdded = true;
      }
    }

    if (scriptsAdded) {
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added npm scripts to package.json');
    }

    // Add bmad-invisible as a dependency
    const needsInstall = !packageJson.dependencies || !packageJson.dependencies['bmad-invisible'];
    if (needsInstall) {
      packageJson.dependencies = packageJson.dependencies || {};
      packageJson.dependencies['bmad-invisible'] = '^1.0.0';
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added bmad-invisible to dependencies');
    }

    // Only create components.json if shadcn MCP server is enabled
    const shadcnEnabled = mcpConfig.mcpServers.shadcn && !mcpConfig.mcpServers.shadcn.disabled;
    if (shadcnEnabled) {
      const componentsPath = path.join(projectRoot, 'components.json');

      // Auto-detect project configuration for smart defaults
      const detectProjectConfig = () => {
        const config = {
          cssPath: 'app/globals.css',
          tailwindConfig: 'tailwind.config.ts',
          useTsx: true,
          useRsc: true,
        };

        // Detect CSS location (common Next.js paths)
        const cssCandidates = [
          'app/globals.css',
          'src/app/globals.css',
          'styles/globals.css',
          'src/styles/globals.css',
        ];
        for (const candidate of cssCandidates) {
          if (fs.existsSync(path.join(projectRoot, candidate))) {
            config.cssPath = candidate;
            break;
          }
        }

        // Detect Tailwind config variant (.ts vs .js)
        if (fs.existsSync(path.join(projectRoot, 'tailwind.config.js'))) {
          config.tailwindConfig = 'tailwind.config.js';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.cjs'))) {
          config.tailwindConfig = 'tailwind.config.cjs';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.mjs'))) {
          config.tailwindConfig = 'tailwind.config.mjs';
        }
        // Default to .ts if nothing found (assume TypeScript project)

        // Detect TypeScript usage
        const hasTsConfig = fs.existsSync(path.join(projectRoot, 'tsconfig.json'));
        const hasTypeScriptDep = fs.existsSync(packagePath) &&
          (() => {
            try {
              const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
              return (pkg.dependencies && pkg.dependencies.typescript) ||
                     (pkg.devDependencies && pkg.devDependencies.typescript);
            } catch {
              return false;
            }
          })();
        config.useTsx = hasTsConfig || hasTypeScriptDep;

        // Detect Next.js App Router vs Pages Router for RSC
        const hasAppDir = fs.existsSync(path.join(projectRoot, 'app')) ||
                         fs.existsSync(path.join(projectRoot, 'src/app'));
        const hasPagesDir = fs.existsSync(path.join(projectRoot, 'pages')) ||
                           fs.existsSync(path.join(projectRoot, 'src/pages'));
        config.useRsc = hasAppDir || !hasPagesDir; // Default to RSC unless Pages Router is clearly used

        return config;
      };

      // Validate shadcn prerequisites
      const validateShadcnPrerequisites = () => {
        const warnings = [];

        try {
          const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
          const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };

          // Check for Next.js (shadcn primarily targets Next.js)
          if (!allDeps.next && !allDeps.react) {
            warnings.push('Neither Next.js nor React detected. shadcn components require React.');
          }

          // Check for Tailwind CSS
          if (!allDeps.tailwindcss) {
            warnings.push('Tailwind CSS not detected. shadcn components require Tailwind CSS.');
          }
        } catch {
          // If we can't read package.json, skip validation (it was just created)
        }

        return warnings;
      };

      const detectedConfig = detectProjectConfig();
      const validationWarnings = validateShadcnPrerequisites();

      // Show validation warnings if any
      if (validationWarnings.length > 0) {
        console.warn('\n⚠️ shadcn prerequisites check:');
        for (const warning of validationWarnings) {
          console.warn(`   • ${warning}`);
        }
        console.warn('   You may need to install these dependencies for shadcn to work properly.\n');
      }

      const shadcnConfig = {
        $schema: 'https://ui.shadcn.com/schema.json',
        style: 'new-york',
        rsc: detectedConfig.useRsc,
        tsx: detectedConfig.useTsx,
        tailwind: {
          config: detectedConfig.tailwindConfig,
          css: detectedConfig.cssPath,
          baseColor: 'zinc',
          cssVariables: true,
        },
        aliases: {
          components: '@/components',
          utils: '@/lib/utils',
        },
        registries: {
          '@originui': 'https://originui.com/r/components.json',
          '@aceternity': 'https://aceternity.com/r/components.json',
          '@magicui': 'https://magicui.design/r/components.json',
        },
      };

      if (!fs.existsSync(componentsPath)) {
        fs.writeFileSync(componentsPath, JSON.stringify(shadcnConfig, null, 2) + '\n');
        console.log('✅ Created shadcn components.json (New York preset)');
        if (detectedConfig.cssPath !== 'app/globals.css' ||
            detectedConfig.tailwindConfig !== 'tailwind.config.ts') {
          console.log(`   📍 Detected paths: ${detectedConfig.cssPath}, ${detectedConfig.tailwindConfig}`);
        }
      } else {
        console.warn('⚠️ components.json already exists. Leaving the current shadcn configuration untouched.');
      }
    } else {
      console.log('ℹ️ Skipped shadcn components.json creation (shadcn MCP server disabled).');
    }

    console.log(`
✨ BMAD-invisible initialized successfully!

Next steps:
  1. Install dependencies:
     npm install


  2. Install Codex CLI if not already installed:
     https://platform.openai.com/docs/guides/codex

  3. Start chatting:
     npm run codex


For detailed documentation, visit:
  https://github.com/bacoco/BMAD-invisible
`);
  },

  codex: async () => {
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const codexScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'bmad-codex')
      : path.join(__dirname, 'bmad-codex');

    if (!fs.existsSync(codexScript)) {
      console.error('❌ BMAD-invisible not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx bmad-invisible init && npm install');
      process.exit(1);
    }

    const child = spawn('node', [codexScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Codex CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  chat: async () => {
    // Check if bmad-invisible is installed locally first
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const chatScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'bmad-claude')
      : path.join(__dirname, 'bmad-claude');

    if (!fs.existsSync(chatScript)) {
      console.error('❌ BMAD-invisible not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx bmad-invisible init && npm install');
      process.exit(1);
    }

    await ensureClaudeEnvironment({ projectRoot: process.cwd(), userArgs: args });

    const child = spawn('node', [chatScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Claude CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  opencode: async () => {
    const child = spawn('opencode', args, {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: false,
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch OpenCode CLI:', error.message);
      console.error('   Make sure OpenCode is installed and in your PATH.');
      console.error('   Visit: https://github.com/openchatai/opencode for installation instructions');
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  install: async () => {
    console.log('📦 Installing BMAD-invisible globally...\n');

    const child = spawn('npm', ['install', '-g', 'bmad-invisible'], {
      stdio: 'inherit',
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n✅ BMAD-invisible installed globally!');
        console.log('You can now use: bmad-invisible <command>');
      }
      process.exit(code || 0);
    });
  },

  build: async () => {
    console.log('🔨 Building MCP server...\n');

    // Check if running from local install or global/npx
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const rootDir = fs.existsSync(localInstall) ? localInstall : path.join(__dirname, '..');

    // The MCP server is already pre-built in dist/, but we'll check TypeScript is available
    const distMcp = path.join(rootDir, 'dist', 'mcp', 'server.js');
    if (fs.existsSync(distMcp)) {
      console.log('✅ MCP server already built and ready!');
      console.log(`   Location: ${distMcp}`);
      return;
    }

    // If not found, try to build it
    const child = spawn('npm', ['run', 'build:mcp'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n✅ MCP server built successfully!');
      }
      process.exit(code || 0);
    });
  },

  test: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['test'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  validate: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['run', 'validate'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  help: () => {
    // Show help message
    printHelp();
  },
};

const setRuntimeContext = (nextCommand, nextArgs = []) => {
  command = nextCommand;
  args = Array.isArray(nextArgs) ? [...nextArgs] : [];
};

const run = (argv = process.argv) => {
  [, , command, ...args] = argv;

  if (!command || command === '--help' || command === '-h') {
    printHelp();
    return Promise.resolve();
  }

  const handler = commands[command];
  if (!handler) {
    console.error(`❌ Unknown command: ${command}`);
    console.log('Run "npx bmad-invisible help" for usage information.');
    process.exit(1);
  }

  try {
    const result = handler();
    if (result && typeof result.then === 'function') {
      return result.catch((error) => {
        console.error('❌ Error:', error.message);
        process.exit(1);
      });
    }

    return Promise.resolve(result);
  } catch (error) {
    console.error('❌ Error:', error.message);
    process.exit(1);
    return Promise.resolve();
  }
};

// Run integrity check only when executed directly (not when imported for testing)
// This ensures the CLI validates package integrity at runtime while allowing
// tests to import and mock functions without triggering validation
if (require.main === module) {
  runIntegrityPreflight(packageRoot, { silentOnMatch: true });

  run().catch((error) => {
    console.error('❌ Error:', error.message);
    process.exit(1);
  });
}

module.exports = {
  commands,
  determineAssistant,
  parseAssistantFromArgs,
  printHelp,
  run,
  runIntegrityPreflight,
  setRuntimeContext,
};
