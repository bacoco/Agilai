#!/usr/bin/env node

/**
 * BMAD Invisible - Main CLI entry point for npx deployment
 *
 * This executable provides easy installation and setup via:
 *   npx bmad-invisible init
 *   npx bmad-invisible chat
 *   npx bmad-invisible install
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { runIntegrityPreflight } = require('../common/utils/integrity');
const { buildAssistantSpawnEnv } = require('../common/utils/assistant-env');

let command;
let args = [];
const packageRoot = path.join(__dirname, '..');

const CLAUDE_PROVIDER_ENV_KEYS = [
  'CLAUDE_CLI_PROVIDER',
  'CLAUDE_CLI_DEFAULT_PROVIDER',
  'CLAUDE_DEFAULT_PROVIDER',
  'CLAUDE_PROVIDER',
  'CLAUDE_CODE_PROVIDER',
];

const parseEnvFile = (filePath) => {
  const parsed = {};
  const raw = fs.readFileSync(filePath, 'utf8');
  const lines = raw.split(/\r?\n/);

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }

    const equalsIndex = trimmed.indexOf('=');
    if (equalsIndex === -1) {
      continue;
    }

    let key = trimmed.slice(0, equalsIndex).trim();
    if (key.startsWith('export ')) {
      key = key.slice('export '.length).trim();
    }

    if (!key) {
      continue;
    }

    let value = trimmed.slice(equalsIndex + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }

    // Validate that value doesn't contain newlines (would break .env format)
    if (value.includes('\n') || value.includes('\r')) {
      console.warn(`⚠️ Skipping invalid .env value for ${key}: contains newline characters`);
      continue;
    }

    parsed[key] = value;
  }

  return parsed;
};

const readProjectEnv = (projectRoot) => {
  const envPath = path.join(projectRoot, '.env');
  if (!fs.existsSync(envPath)) {
    return { values: {}, path: envPath };
  }

  try {
    return { values: parseEnvFile(envPath), path: envPath };
  } catch (error) {
    console.warn(
      `⚠️ Unable to parse ${envPath}: ${error.message || error}. Continuing without it.`,
    );
    return { values: {}, path: envPath };
  }
};

const isInteractiveTerminal = () => Boolean(process.stdin.isTTY && process.stdout.isTTY);

/**
 * Parses provider from CLI arguments.
 * Precedence: CLI args > process env vars > .env file > interactive prompts
 */
const parseProviderFromArgs = (cliArgs = []) => {
  for (let index = 0; index < cliArgs.length; index += 1) {
    const arg = cliArgs[index];

    if (arg === '--provider' || arg.startsWith('--provider=')) {
      const value = arg === '--provider' ? cliArgs[index + 1] : arg.split('=')[1];
      if (value && typeof value === 'string' && value.trim()) {
        return value.trim().toLowerCase();
      }
    }
  }

  return undefined;
};

const determineClaudeProvider = (cliArgs = [], envFromFile = {}) => {
  const fromArgs = parseProviderFromArgs(cliArgs);
  if (fromArgs) {
    return fromArgs;
  }

  for (const key of CLAUDE_PROVIDER_ENV_KEYS) {
    const value = process.env[key] || envFromFile[key];
    if (typeof value === 'string' && value.trim()) {
      return value.trim().toLowerCase();
    }
  }

  return undefined;
};

const promptForInput = (question) =>
  new Promise((resolve, reject) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    let cleanedUp = false;
    const cleanup = () => {
      if (cleanedUp) return;
      cleanedUp = true;
      try {
        rl.close();
      } catch {
        // Ignore cleanup errors
      }
    };

    // Timeout after 5 minutes to prevent hanging
    const timeout = setTimeout(() => {
      cleanup();
      reject(new Error('Input prompt timed out after 5 minutes'));
    }, 300000);

    rl.on('error', (error) => {
      clearTimeout(timeout);
      cleanup();
      reject(error);
    });

    rl.question(question, (answer) => {
      clearTimeout(timeout);
      cleanup();
      resolve(answer);
    });
  });

const promptForGlmCredentials = async ({ existingBaseUrl } = {}) => {
  console.log('🔐 GLM provider selected. A Z.AI API token is required.');

  let apiKey;
  while (!apiKey) {
    // eslint-disable-next-line no-await-in-loop
    const input = await promptForInput('Enter your Z.AI GLM API token: ');
    const trimmed = (input || '').trim();
    if (trimmed) {
      apiKey = trimmed;
    } else {
      console.log('⚠️ Token cannot be empty. Please provide a valid value.');
    }
  }

  const baseUrlPrompt = existingBaseUrl
    ? `Enter a custom GLM base URL (leave blank to keep ${existingBaseUrl}): `
    : 'Enter a custom GLM base URL (leave blank for the CLI default): ';
  const baseUrlInput = await promptForInput(baseUrlPrompt);
  const baseUrl = (baseUrlInput || '').trim();

  return { apiKey, baseUrl: baseUrl || undefined };
};

const promptToPersistGlmEnv = async () => {
  if (!isInteractiveTerminal()) {
    return false;
  }

  try {
    const answer = await promptForInput(
      'Would you like to save these GLM credentials to .env for future runs? (y/N): ',
    );
    const normalized = (answer || '').trim().toLowerCase();
    return normalized === 'y' || normalized === 'yes';
  } catch (error) {
    console.warn(
      `⚠️ Skipping persistence prompt due to an input error: ${error.message || error}`,
    );
    return false;
  }
};

const persistEnvValues = (envPath, updates) => {
  const normalizedUpdates = Object.entries(updates).reduce((acc, [key, value]) => {
    if (typeof value === 'string' && value) {
      // Validate no newlines in values
      if (value.includes('\n') || value.includes('\r')) {
        console.warn(`⚠️ Skipping ${key}: value contains newline characters`);
        return acc;
      }
      acc[key] = value;
    }
    return acc;
  }, {});

  const updateKeys = Object.keys(normalizedUpdates);
  if (updateKeys.length === 0) {
    return;
  }

  let lines = [];
  if (fs.existsSync(envPath)) {
    lines = fs.readFileSync(envPath, 'utf8').split(/\r?\n/);
  }

  const seenKeys = new Set();
  const updatedLines = lines.map((line) => {
    const match = line.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=(.*)$/);
    if (!match) {
      return line;
    }

    const key = match[1];
    if (Object.prototype.hasOwnProperty.call(normalizedUpdates, key)) {
      seenKeys.add(key);
      return `${key}=${normalizedUpdates[key]}`;
    }

    return line;
  });

  for (const key of updateKeys) {
    if (!seenKeys.has(key)) {
      updatedLines.push(`${key}=${normalizedUpdates[key]}`);
    }
  }

  const finalContent = updatedLines.join('\n') + '\n';

  fs.writeFileSync(envPath, finalContent);
  console.log('⚠️  WARNING: Keep this file secure and never commit it to version control.');
};

const ensureClaudeEnvironment = async ({ projectRoot, userArgs = [] }) => {
  const { values: fileEnv, path: envPath } = readProjectEnv(projectRoot);

  const anthropicToken = process.env.ANTHROPIC_AUTH_TOKEN || fileEnv.ANTHROPIC_AUTH_TOKEN;
  if (anthropicToken && !process.env.ANTHROPIC_AUTH_TOKEN) {
    process.env.ANTHROPIC_AUTH_TOKEN = anthropicToken;
  }

  const glmKeyFromProcess = process.env.GLM_API_KEY;
  const glmKeyFromFile = fileEnv.GLM_API_KEY;
  const glmBaseFromProcess = process.env.GLM_BASE_URL;
  const glmBaseFromFile = fileEnv.GLM_BASE_URL;

  if (!glmKeyFromProcess && glmKeyFromFile) {
    process.env.GLM_API_KEY = glmKeyFromFile;
  }

  if (!glmBaseFromProcess && glmBaseFromFile) {
    process.env.GLM_BASE_URL = glmBaseFromFile;
  }

  const provider = determineClaudeProvider(userArgs, fileEnv);
  if (provider !== 'glm') {
    return;
  }

  const effectiveBaseUrl = process.env.GLM_BASE_URL || glmBaseFromFile;

  if (process.env.GLM_API_KEY) {
    return;
  }

  if (!isInteractiveTerminal()) {
    console.error('❌ GLM provider selected but GLM_API_KEY is not set.');
    console.error(
      '   Provide GLM_API_KEY (and optional GLM_BASE_URL) via environment variables or a project .env file before running in non-interactive mode.',
    );
    process.exit(1);
  }

  let credentials;
  try {
    credentials = await promptForGlmCredentials({ existingBaseUrl: effectiveBaseUrl });
  } catch (error) {
    console.error('❌ Failed to read GLM credentials:', error.message || error);
    process.exit(1);
  }

  process.env.GLM_API_KEY = credentials.apiKey;
  if (credentials.baseUrl) {
    process.env.GLM_BASE_URL = credentials.baseUrl;
  } else if (effectiveBaseUrl) {
    process.env.GLM_BASE_URL = effectiveBaseUrl;
  }

  const shouldPersist = await promptToPersistGlmEnv();
  if (!shouldPersist) {
    console.log('ℹ️ Skipped saving GLM credentials to .env.');
    return;
  }

  const updates = { GLM_API_KEY: credentials.apiKey };
  const baseToPersist = credentials.baseUrl || effectiveBaseUrl;
  if (baseToPersist) {
    updates.GLM_BASE_URL = baseToPersist;
  }

  try {
    persistEnvValues(envPath, updates);
    const relativeEnvPath = path.relative(process.cwd(), envPath) || '.env';
    console.log(`💾 Saved GLM credentials to ${relativeEnvPath}`);
  } catch (error) {
    console.warn(`⚠️ Unable to persist GLM credentials: ${error.message || error}`);
  }
};

const createDefaultRuntimeOptions = () => ({
  llmProvider: undefined,
  llmModel: undefined,
});

let runtimeOptions = createDefaultRuntimeOptions();

const VALID_LLM_PROVIDERS = new Set(['claude', 'glm', 'openai', 'gpt', 'gemini', 'google']);

const normalizeLlmProvider = (value) => {
  if (!value) {
    return undefined;
  }

  const normalized = value.toLowerCase();

  if (normalized === 'anthropic') {
    return 'claude';
  }

  if (normalized === 'zhipu') {
    return 'glm';
  }

  return normalized;
};

const parseLlmOptionsFromArgs = (currentArgs) => {
  let provider;
  let model;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--glm') {
      provider = 'glm';
      continue;
    }

    if (arg === '--anthropic') {
      provider = 'claude';
      continue;
    }

    if (arg === '--llm-provider') {
      provider = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--llm-provider=')) {
      provider = arg.split('=')[1];
      continue;
    }

    if (arg === '--llm-model') {
      model = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--llm-model=')) {
      model = arg.split('=')[1];
      continue;
    }

    sanitized.push(arg);
  }

  return { provider: normalizeLlmProvider(provider), model, sanitized };
};

const consumeLlmOptionsFromArgs = () => {
  if (!args.length) {
    return;
  }

  const { provider, model, sanitized } = parseLlmOptionsFromArgs(args);
  args.splice(0, args.length, ...sanitized);

  if (provider) {
    if (!VALID_LLM_PROVIDERS.has(provider)) {
      console.error('⚠️ Unsupported LLM provider flag value:', provider);
      console.error('Valid providers:', Array.from(VALID_LLM_PROVIDERS).join(', '));
      process.exit(1);
      return;
    }

    runtimeOptions.llmProvider = provider;
  }

  if (model) {
    runtimeOptions.llmModel = model;
  }
};

const buildSpawnEnv = () => {
  const env = { ...process.env };

  if (runtimeOptions.llmProvider) {
    env.LLM_PROVIDER = runtimeOptions.llmProvider;

    if (runtimeOptions.llmProvider === 'glm') {
      const existingKey = env.ZHIPUAI_API_KEY || env.GLM_API_KEY;
      if (existingKey && !env.ZHIPUAI_API_KEY) {
        env.ZHIPUAI_API_KEY = existingKey;
      }
    }
  }

  if (runtimeOptions.llmModel) {
    env.LLM_MODEL = runtimeOptions.llmModel;
  }

  return env;
};

// Get current package version
const packageJsonPath = path.join(__dirname, '..', 'package.json');
const currentVersion = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')).version;

const printHelp = () => {
  console.log(`
BMAD Invisible - Zero-knowledge AI orchestration (v${currentVersion})

Usage:
  npx bmad-invisible@latest <command> [options]

Options:
  --assistant=<assistant>    Launch specified CLI front-end (claude, codex, opencode)
  --llm-provider=<provider>  Override orchestrator LLM (claude, glm, openai, gemini)
  --llm-model=<model>        Force a specific model id for the orchestrator
  --glm                      Shortcut for --llm-provider=glm (uses ZHIPUAI_API_KEY)
  --anthropic                Shortcut for --llm-provider=claude

Commands:

  start                🚀 ONE-COMMAND SETUP: init + install + prompt for assistant choice
  init                 Initialize BMAD-invisible in current project
  chat                 Start conversational interface with Claude CLI (Anthropic/GLM)
  codex                Start conversational interface with Codex CLI
  opencode             Start conversational interface with OpenCode CLI

  install              Install BMAD-invisible globally
  build                Build MCP server
  test                 Run test suite
  validate             Validate configuration
  help                 Show this help message

Examples:

  npx bmad-invisible@latest start      # 🚀 Do everything in one command!
  npx bmad-invisible@latest start --assistant=claude --provider=glm
                                      # Skip prompts & launch Claude with GLM
  npx bmad-invisible@latest start --assistant=claude-glm
                                      # Combined flag also supported
  npx bmad-invisible@latest start --assistant=opencode
                                      # Skip the prompt and launch OpenCode
  npx bmad-invisible@latest start --glm
                                      # Use GLM with ZHIPUAI_API_KEY / GLM_API_KEY
  npx bmad-invisible@latest init       # Setup in current project
  npm run codex                        # Start conversation (after install)


Flags:
  Use --assistant and optionally --provider to skip prompts. Combine values like
  --assistant=claude-glm when preferred.


💡 Tip: Always use @latest to get the newest version:
   npx bmad-invisible@latest start

Environment:
  Set ZHIPUAI_API_KEY (or GLM_API_KEY) and optionally LLM_MODEL when using --glm.
  Use --anthropic or LLM_PROVIDER=claude to switch back to Anthropic defaults.

For more information: https://github.com/bacoco/BMAD-invisible
`);
};

const ASSISTANT_CHOICES = [
  {
    id: 'claude',
    providers: ['anthropic', 'glm'],
  },
  {
    id: 'codex',
    providers: ['anthropic'],
  },
  {
    id: 'opencode',
    providers: ['anthropic'],
  },
];

const findAssistantChoice = (id) =>
  ASSISTANT_CHOICES.find((choice) => choice.id === id);

const listAssistantIds = () => ASSISTANT_CHOICES.map(({ id }) => id);

const splitAssistantAndProvider = (value) => {
  if (!value) {
    return { assistant: undefined, provider: undefined };
  }

  const normalized = value.toLowerCase();
  const [assistantPart, ...providerParts] = normalized.split('-');
  const provider = providerParts.length > 0 ? providerParts.join('-') : undefined;

  return {
    assistant: assistantPart,
    provider,
  };
};

const OPTIONAL_MCP_SERVERS = [
  {
    id: 'chrome-devtools',
    label: 'Chrome DevTools bridge',
    description: 'Inspect and control active Chrome tabs via the DevTools protocol.',
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-chrome-devtools'],
      disabled: false,
    },
  },
  {
    id: 'shadcn',
    label: 'shadcn/ui component generator',
    description: 'Generate UI components from the shadcn library.',
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-shadcn'],
      disabled: false,
    },
  },
];

const formatAssistantName = (value) =>
  value.charAt(0).toUpperCase() + value.slice(1);

const parseAssistantFromArgs = (currentArgs) => {
  let assistant;
  let provider;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--assistant') {
      assistant = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--assistant=')) {
      assistant = arg.split('=')[1];
      continue;
    }

    if (arg === '--provider') {
      provider = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--provider=')) {
      provider = arg.split('=')[1];
      continue;
    }

    sanitized.push(arg);
  }

  if (assistant) {
    const { assistant: parsedAssistant, provider: combinedProvider } =
      splitAssistantAndProvider(assistant);
    assistant = parsedAssistant;
    if (!provider && combinedProvider) {
      provider = combinedProvider;
    }
  }

  return {
    assistant: assistant ? assistant.toLowerCase() : undefined,
    provider: provider ? provider.toLowerCase() : undefined,
    sanitized,
  };
};

const promptForAssistant = async () => {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const askQuestion = (prompt) =>
    new Promise((resolve, reject) => {
      const handleError = (error) => {
        rl.removeListener('error', handleError);
        reject(error);
      };

      rl.once('error', handleError);
      rl.question(prompt, (answer) => {
        rl.removeListener('error', handleError);
        resolve(answer);
      });
    });

  try {
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const options = ASSISTANT_CHOICES.map((choice) => {
        const providersLabel =
          choice.providers.length > 1
            ? ` (${choice.providers.join('/')})`
            : '';
        return `${formatAssistantName(choice.id)}${providersLabel}`;
      }).join(' / ');

      const answer = (await askQuestion(
        `Which assistant should we launch? (${options}): `,
      ))
        .trim()
        .toLowerCase();

      if (!answer) {
        console.log('⚠️ No assistant selected. Please choose one.');
        continue;
      }

      const { assistant: selectedAssistant, provider: embeddedProvider } =
        splitAssistantAndProvider(answer);
      const choice = findAssistantChoice(selectedAssistant);

      if (!choice) {
        console.log('⚠️ Unrecognized selection. Please try again.');
        continue;
      }

      let provider = embeddedProvider;

      if (provider && !choice.providers.includes(provider)) {
        console.log('⚠️ Unsupported provider for that assistant. Please try again.');
        continue;
      }

      if (!provider) {
        if (choice.providers.length === 1) {
          provider = choice.providers[0];
        } else {
          const providerAnswer = (await askQuestion(
            `Which provider should power ${formatAssistantName(choice.id)}? (${choice.providers.join(
              '/',
            )}): `,
          ))
            .trim()
            .toLowerCase();

          if (!providerAnswer) {
            console.log('⚠️ No provider selected. Please try again.');
            continue;
          }

          if (!choice.providers.includes(providerAnswer)) {
            console.log('⚠️ Unsupported provider. Please try again.');
            continue;
          }

          provider = providerAnswer;
        }
      }

      return { assistant: choice.id, provider };
    }
  } finally {
    try {
      rl.close();
    } catch {
      // Ignore cleanup errors
    }
  }
};

const determineAssistant = async (input = {}) => {
  if (typeof input === 'string' || input === undefined) {
    return determineAssistant({ assistant: input });
  }

  const { assistant: assistantFlag, provider: providerFlag } = input;
  if (assistantFlag) {
    const { assistant: normalizedAssistant, provider: combinedProvider } =
      splitAssistantAndProvider(assistantFlag);
    let provider = providerFlag || combinedProvider;
    const choice = findAssistantChoice(normalizedAssistant);

    if (!choice) {
      console.error('⚠️ Unsupported assistant flag value:', assistantFlag);
      console.error('Valid options:', listAssistantIds().join(', '));
      process.exit(1);
      return; // For testing when exit is mocked
    }

    if (provider && !choice.providers.includes(provider)) {
      console.error(
        `⚠️ Unsupported provider "${provider}" for assistant "${normalizedAssistant}".`,
      );
      console.error(
        `Valid providers for ${normalizedAssistant}: ${choice.providers.join(', ')}`,
      );
      process.exit(1);
      return; // For testing when exit is mocked
    }

    if (!provider) {
      [provider] = choice.providers;
    }

    return { assistant: choice.id, provider };
  }

  if (!process.stdout.isTTY) {
    console.error(
      '⚠️ Non-interactive mode requires --assistant flag. Use: --assistant=claude, --assistant=claude-glm, or combine with --provider.',
    );
    process.exit(1);
    return; // For testing when exit is mocked
  }

  return promptForAssistant();
};

// Command handlers
const commands = {
  start: async () => {
    console.log('🚀 Starting BMAD-invisible setup...\n');

    consumeLlmOptionsFromArgs();

    // Determine assistant preference before installation begins
    const {
      assistant: assistantFlag,
      provider: providerFlag,
      sanitized,
    } = parseAssistantFromArgs(args);
    args.splice(0, args.length, ...sanitized);
    const selection = await determineAssistant({
      assistant: assistantFlag,
      provider: providerFlag,
    });

    // If selection is undefined, exit was called (possibly mocked in tests)
    if (!selection) {
      return;
    }

    const { assistant, provider } = selection;
    process.env.BMAD_ASSISTANT_PROVIDER = provider;

    if (process.stdout.isTTY) {
      console.log(
        '💡 We can optionally enable additional MCP servers (chrome-devtools, shadcn) during setup.',
      );
    }

    // Run init
    await commands.init();

    // Run npm install
    console.log('\n📦 Installing dependencies...\n');
    const install = spawn('npm', ['install'], {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: true,
    });

    await new Promise((resolve, reject) => {
      install.on('exit', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error('npm install failed'));
        }
      });
    });

    const assistantName = formatAssistantName(assistant);
    const providerLabel = provider ? ` (${provider})` : '';
    console.log(
      `\n🎯 Starting BMAD Invisible Orchestrator with ${assistantName}${providerLabel}...\n`,
    );

    if (assistant === 'claude') {
      await commands.chat();
      return;
    }

    if (assistant === 'opencode') {
      await commands.opencode();
      return;
    }

    await commands.codex();
  },

  init: async () => {
    console.log('🚀 Initializing BMAD-invisible...\n');

    const projectRoot = process.cwd();
    const packagePath = path.join(projectRoot, 'package.json');

    // Create package.json if it doesn't exist
    if (!fs.existsSync(packagePath)) {
      console.log('📦 Creating package.json...');
      const defaultPackage = {
        name: path.basename(projectRoot),
        version: '1.0.0',
        description: 'Project powered by BMAD-invisible',
        scripts: {},
        keywords: [],
        author: '',
        license: 'ISC',
      };
      fs.writeFileSync(packagePath, JSON.stringify(defaultPackage, null, 2) + '\n');
      console.log('✅ Created package.json');
    }

    // Create .bmad-invisible directory
    const bmadDir = path.join(projectRoot, '.bmad-invisible');
    if (!fs.existsSync(bmadDir)) {
      fs.mkdirSync(bmadDir, { recursive: true });
      console.log('✅ Created .bmad-invisible directory');
    }

    // Create .claude directory for MCP config
    const claudeDir = path.join(projectRoot, '.claude');
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
      console.log('✅ Created .claude directory');
    }

    // Create MCP config (inline template since we might be running from npx cache)
    const mcpConfigDest = path.join(claudeDir, 'mcp-config.json');
    let mcpConfig = { mcpServers: {} };
    let hadExistingMcpConfig = false;
    if (fs.existsSync(mcpConfigDest)) {
      try {
        const parsed = JSON.parse(fs.readFileSync(mcpConfigDest, 'utf8'));
        if (parsed && typeof parsed === 'object' && parsed.mcpServers) {
          // Preserve all top-level keys (logging, environment, etc.), not just mcpServers
          mcpConfig = { ...parsed };
          mcpConfig.mcpServers = { ...parsed.mcpServers };
          hadExistingMcpConfig = true;
        }
      } catch (error) {
        console.warn('⚠️ Failed to parse existing MCP configuration. Rebuilding from defaults.');
      }
    }

    const orchestratorKey = 'bmad-invisible-orchestrator';
    const orchestratorConfig = {
      command: 'node',
      args: ['${workspaceFolder}/node_modules/bmad-invisible/dist/mcp/mcp/server.js'],
      disabled: false,
    };

    if (!mcpConfig.mcpServers[orchestratorKey]) {
      mcpConfig.mcpServers[orchestratorKey] = orchestratorConfig;
      console.log('✅ Added BMAD-invisible orchestrator MCP server');
    } else {
      // Ensure orchestrator is enabled during re-init (user may have disabled it)
      mcpConfig.mcpServers[orchestratorKey].disabled = false;
    }

    const promptYesNo = async (question) => {
      if (!process.stdout.isTTY) {
        return false;
      }

      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        let cleanedUp = false;
        const cleanup = () => {
          if (cleanedUp) return;
          cleanedUp = true;
          try {
            rl.close();
          } catch {
            // ignore cleanup errors
          }
        };

        rl.on('error', (error) => {
          cleanup();
          reject(error);
        });

        rl.question(`${question} (y/N): `, (answer) => {
          cleanup();
          const normalized = (answer || '').trim().toLowerCase();
          resolve(normalized === 'y' || normalized === 'yes');
        });
      });
    };

    const optionalServerPromptsNeeded = OPTIONAL_MCP_SERVERS.filter(
      ({ id }) => !mcpConfig.mcpServers[id],
    );

    if (optionalServerPromptsNeeded.length > 0) {
      if (process.stdout.isTTY) {
        console.log('\n✨ Optional MCP servers available:');
        for (const server of optionalServerPromptsNeeded) {
          console.log(`   • ${server.label} — ${server.description}`);
        }
        console.log('');
      } else {
        console.log(
          'ℹ️ Optional MCP servers detected, but prompts are skipped in non-interactive mode.',
        );
      }
    }

    for (const optional of OPTIONAL_MCP_SERVERS) {
      if (mcpConfig.mcpServers[optional.id]) {
        continue;
      }

      let shouldAdd = false;
      try {
        shouldAdd = await promptYesNo(`Would you like to enable the ${optional.label}?`);
      } catch (error) {
        console.warn(
          `⚠️ Skipping ${optional.label} prompt due to an input error: ${error.message || error}`,
        );
      }

      if (shouldAdd) {
        mcpConfig.mcpServers[optional.id] = { ...optional.config };
        console.log(`✅ Added optional MCP server: ${optional.label}`);
      } else {
        console.log(`⏭️ Skipped optional MCP server: ${optional.label}`);
      }
    }

    fs.writeFileSync(mcpConfigDest, JSON.stringify(mcpConfig, null, 2) + '\n');
    console.log(
      hadExistingMcpConfig
        ? '✅ Updated MCP configuration with selected servers'
        : '✅ Created MCP configuration',
    );

    // Create docs directory
    const docsDir = path.join(projectRoot, 'docs');
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
      console.log('✅ Created docs directory');
    }

    // Add to package.json scripts
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    packageJson.scripts = packageJson.scripts || {};

    const scriptsToAdd = {
      bmad: 'bmad-invisible start',
      codex: 'bmad-invisible codex',
      'bmad:codex': 'bmad-invisible codex',
      'bmad:claude': 'bmad-invisible chat',
      'bmad:opencode': 'bmad-invisible opencode',
      'bmad:build': 'bmad-invisible build',
    };

    let scriptsAdded = false;
    for (const [key, value] of Object.entries(scriptsToAdd)) {
      if (!packageJson.scripts[key]) {
        packageJson.scripts[key] = value;
        scriptsAdded = true;
      }
    }

    if (scriptsAdded) {
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added npm scripts to package.json');
    }

    // Add bmad-invisible as a dependency
    const needsInstall = !packageJson.dependencies || !packageJson.dependencies['bmad-invisible'];
    if (needsInstall) {
      packageJson.dependencies = packageJson.dependencies || {};
      packageJson.dependencies['bmad-invisible'] = '^1.0.0';
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added bmad-invisible to dependencies');
    }

    // Only create components.json if shadcn MCP server is enabled
    const shadcnEnabled = mcpConfig.mcpServers.shadcn && !mcpConfig.mcpServers.shadcn.disabled;
    if (shadcnEnabled) {
      const componentsPath = path.join(projectRoot, 'components.json');

      // Auto-detect project configuration for smart defaults
      const detectProjectConfig = () => {
        const config = {
          cssPath: 'app/globals.css',
          tailwindConfig: 'tailwind.config.ts',
          useTsx: true,
          useRsc: true,
        };

        // Detect CSS location (common Next.js paths)
        const cssCandidates = [
          'app/globals.css',
          'src/app/globals.css',
          'styles/globals.css',
          'src/styles/globals.css',
        ];
        for (const candidate of cssCandidates) {
          if (fs.existsSync(path.join(projectRoot, candidate))) {
            config.cssPath = candidate;
            break;
          }
        }

        // Detect Tailwind config variant (.ts vs .js)
        if (fs.existsSync(path.join(projectRoot, 'tailwind.config.js'))) {
          config.tailwindConfig = 'tailwind.config.js';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.cjs'))) {
          config.tailwindConfig = 'tailwind.config.cjs';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.mjs'))) {
          config.tailwindConfig = 'tailwind.config.mjs';
        }
        // Default to .ts if nothing found (assume TypeScript project)

        // Detect TypeScript usage
        const hasTsConfig = fs.existsSync(path.join(projectRoot, 'tsconfig.json'));
        const hasTypeScriptDep = fs.existsSync(packagePath) &&
          (() => {
            try {
              const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
              return (pkg.dependencies && pkg.dependencies.typescript) ||
                     (pkg.devDependencies && pkg.devDependencies.typescript);
            } catch {
              return false;
            }
          })();
        config.useTsx = hasTsConfig || hasTypeScriptDep;

        // Detect Next.js App Router vs Pages Router for RSC
        const hasAppDir = fs.existsSync(path.join(projectRoot, 'app')) ||
                         fs.existsSync(path.join(projectRoot, 'src/app'));
        const hasPagesDir = fs.existsSync(path.join(projectRoot, 'pages')) ||
                           fs.existsSync(path.join(projectRoot, 'src/pages'));
        config.useRsc = hasAppDir || !hasPagesDir; // Default to RSC unless Pages Router is clearly used

        return config;
      };

      // Validate shadcn prerequisites
      const validateShadcnPrerequisites = () => {
        const warnings = [];

        try {
          const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
          const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };

          // Check for Next.js (shadcn primarily targets Next.js)
          if (!allDeps.next && !allDeps.react) {
            warnings.push('Neither Next.js nor React detected. shadcn components require React.');
          }

          // Check for Tailwind CSS
          if (!allDeps.tailwindcss) {
            warnings.push('Tailwind CSS not detected. shadcn components require Tailwind CSS.');
          }
        } catch {
          // If we can't read package.json, skip validation (it was just created)
        }

        return warnings;
      };

      const detectedConfig = detectProjectConfig();
      const validationWarnings = validateShadcnPrerequisites();

      // Show validation warnings if any
      if (validationWarnings.length > 0) {
        console.warn('\n⚠️ shadcn prerequisites check:');
        for (const warning of validationWarnings) {
          console.warn(`   • ${warning}`);
        }
        console.warn('   You may need to install these dependencies for shadcn to work properly.\n');
      }

      const shadcnConfig = {
        $schema: 'https://ui.shadcn.com/schema.json',
        style: 'new-york',
        rsc: detectedConfig.useRsc,
        tsx: detectedConfig.useTsx,
        tailwind: {
          config: detectedConfig.tailwindConfig,
          css: detectedConfig.cssPath,
          baseColor: 'zinc',
          cssVariables: true,
        },
        aliases: {
          components: '@/components',
          utils: '@/lib/utils',
        },
        registries: {
          '@originui': 'https://originui.com/r/components.json',
          '@aceternity': 'https://aceternity.com/r/components.json',
          '@magicui': 'https://magicui.design/r/components.json',
        },
      };

      if (!fs.existsSync(componentsPath)) {
        fs.writeFileSync(componentsPath, JSON.stringify(shadcnConfig, null, 2) + '\n');
        console.log('✅ Created shadcn components.json (New York preset)');
        if (detectedConfig.cssPath !== 'app/globals.css' ||
            detectedConfig.tailwindConfig !== 'tailwind.config.ts') {
          console.log(`   📍 Detected paths: ${detectedConfig.cssPath}, ${detectedConfig.tailwindConfig}`);
        }
      } else {
        console.warn('⚠️ components.json already exists. Leaving the current shadcn configuration untouched.');
      }
    } else {
      console.log('ℹ️ Skipped shadcn components.json creation (shadcn MCP server disabled).');
    }

    console.log(`
✨ BMAD-invisible initialized successfully!

Next steps:
  1. Install dependencies:
     npm install


  2. Install Codex CLI if not already installed:
     https://platform.openai.com/docs/guides/codex

  3. Start chatting:
     npm run codex


For detailed documentation, visit:
  https://github.com/bacoco/BMAD-invisible
`);
  },

  codex: async () => {
    consumeLlmOptionsFromArgs();

    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const codexScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'bmad-codex')
      : path.join(__dirname, 'bmad-codex');

    if (!fs.existsSync(codexScript)) {
      console.error('❌ BMAD-invisible not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx bmad-invisible init && npm install');
      process.exit(1);
    }

    const child = spawn('node', [codexScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
      env: buildSpawnEnv(),
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Codex CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  chat: async () => {
    consumeLlmOptionsFromArgs();

    // Check if bmad-invisible is installed locally first
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const chatScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'bmad-claude')
      : path.join(__dirname, 'bmad-claude');

    if (!fs.existsSync(chatScript)) {
      console.error('❌ BMAD-invisible not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx bmad-invisible init && npm install');
      process.exit(1);
    }

    await ensureClaudeEnvironment({ projectRoot: process.cwd(), userArgs: args });

    const child = spawn('node', [chatScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
      env: buildSpawnEnv(),
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Claude CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  opencode: async () => {
    const { env: opencodeEnv, isGlm } = buildAssistantSpawnEnv();

    if (isGlm) {
      console.log('🌐 GLM mode active: routing OpenCode CLI through configured GLM endpoint.');
    }

    const child = spawn('opencode', args, {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: false,
      env: opencodeEnv,
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch OpenCode CLI:', error.message);
      console.error('   Make sure OpenCode is installed and in your PATH.');
      console.error('   Visit: https://github.com/openchatai/opencode for installation instructions');
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  install: async () => {
    console.log('📦 Installing BMAD-invisible globally...\n');

    const child = spawn('npm', ['install', '-g', 'bmad-invisible'], {
      stdio: 'inherit',
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n✅ BMAD-invisible installed globally!');
        console.log('You can now use: bmad-invisible <command>');
      }
      process.exit(code || 0);
    });
  },

  build: async () => {
    console.log('🔨 Building MCP server...\n');

    // Check if running from local install or global/npx
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const rootDir = fs.existsSync(localInstall) ? localInstall : path.join(__dirname, '..');

    // The MCP server is already pre-built in dist/, but we'll check TypeScript is available
    const packagedEntryCandidates = [
      path.join(rootDir, 'dist', 'mcp', 'mcp', 'server.js'),
      path.join(rootDir, 'dist', 'mcp', 'server.js'),
    ];
    const resolvedPackagedEntry = packagedEntryCandidates.find((candidate) =>
      fs.existsSync(candidate),
    );

    if (resolvedPackagedEntry) {
      console.log('✅ MCP server already built and ready!');
      console.log(`   Entry point: ${resolvedPackagedEntry}`);
      return;
    }

    // If not found, try to build it
    const child = spawn('npm', ['run', 'build:mcp'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        const builtEntry = packagedEntryCandidates.find((candidate) =>
          fs.existsSync(candidate),
        );
        console.log('\n✅ MCP server built successfully!');
        if (builtEntry) {
          console.log(`   Entry point: ${builtEntry}`);
        }
      }
      process.exit(code || 0);
    });
  },

  test: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['test'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  validate: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['run', 'validate'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  help: () => {
    // Show help message
    printHelp();
  },
};

const setRuntimeContext = (nextCommand, nextArgs = [], options = {}) => {
  command = nextCommand;
  args = Array.isArray(nextArgs) ? [...nextArgs] : [];
  runtimeOptions = { ...createDefaultRuntimeOptions(), ...(options.runtimeOptions || {}) };
};

const run = (argv = process.argv) => {
  runtimeOptions = createDefaultRuntimeOptions();
  [, , command, ...args] = argv;

  if (!command || command === '--help' || command === '-h') {
    printHelp();
    return Promise.resolve();
  }

  const handler = commands[command];
  if (!handler) {
    console.error(`❌ Unknown command: ${command}`);
    console.log('Run "npx bmad-invisible help" for usage information.');
    process.exit(1);
  }

  try {
    const result = handler();
    if (result && typeof result.then === 'function') {
      return result.catch((error) => {
        console.error('❌ Error:', error.message);
        process.exit(1);
      });
    }

    return Promise.resolve(result);
  } catch (error) {
    console.error('❌ Error:', error.message);
    process.exit(1);
    return Promise.resolve();
  }
};

// Run integrity check only when executed directly (not when imported for testing)
// This ensures the CLI validates package integrity at runtime while allowing
// tests to import and mock functions without triggering validation
if (require.main === module) {
  runIntegrityPreflight(packageRoot, { silentOnMatch: true });

  run().catch((error) => {
    console.error('❌ Error:', error.message);
    process.exit(1);
  });
}

module.exports = {
  commands,
  determineAssistant,
  parseAssistantFromArgs,
  printHelp,
  run,
  runIntegrityPreflight,
  setRuntimeContext,
};
