#!/usr/bin/env node

/**
 * BMAD Invisible - Main CLI entry point for npx deployment
 *
 * This executable provides easy installation and setup via:
 *   npx bmad-invisible init
 *   npx bmad-invisible chat
 *   npx bmad-invisible install
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { runIntegrityPreflight } = require('../common/utils/integrity');

let command;
let args = [];
const packageRoot = path.join(__dirname, '..');

// Get current package version
const packageJsonPath = path.join(__dirname, '..', 'package.json');
const currentVersion = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')).version;

const printHelp = () => {
  console.log(`
BMAD Invisible - Zero-knowledge AI orchestration (v${currentVersion})

Usage:
  npx bmad-invisible@latest <command> [options]

Commands:

  start                🚀 ONE-COMMAND SETUP: init + install + prompt for assistant choice
  init                 Initialize BMAD-invisible in current project
  chat                 Start conversational interface with Claude CLI
  codex                Start conversational interface with Codex CLI
  opencode             Start conversational interface with OpenCode CLI

  install              Install BMAD-invisible globally
  build                Build MCP server
  test                 Run test suite
  validate             Validate configuration
  help                 Show this help message

Examples:

  npx bmad-invisible@latest start      # 🚀 Do everything in one command!
  npx bmad-invisible@latest start --assistant=opencode
                                      # Skip the prompt and launch OpenCode
  npx bmad-invisible@latest init       # Setup in current project
  npm run codex                        # Start conversation (after install)


💡 Tip: Always use @latest to get the newest version:
   npx bmad-invisible@latest start

For more information: https://github.com/bacoco/BMAD-invisible
`);
};

const ASSISTANT_CHOICES = ['claude', 'codex', 'opencode'];

const OPTIONAL_MCP_SERVERS = [
  {
    id: 'chrome-devtools',
    label: 'Chrome DevTools bridge',
    description: 'Inspect and control active Chrome tabs via the DevTools protocol.',
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-chrome-devtools'],
      disabled: false,
    },
  },
  {
    id: 'shadcn',
    label: 'shadcn/ui component generator',
    description: 'Generate UI components from the shadcn library.',
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-shadcn'],
      disabled: false,
    },
  },
];

const formatAssistantName = (value) =>
  value.charAt(0).toUpperCase() + value.slice(1);

const parseAssistantFromArgs = (currentArgs) => {
  let assistant;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--assistant') {
      assistant = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--assistant=')) {
      assistant = arg.split('=')[1];
      continue;
    }

    sanitized.push(arg);
  }

  return {
    assistant: assistant ? assistant.toLowerCase() : undefined,
    sanitized,
  };
};

const promptForAssistant = () =>
  new Promise((resolve, reject) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    // Ensure readline is cleaned up on error
    let cleanedUp = false;
    const cleanup = () => {
      if (cleanedUp) return;
      cleanedUp = true;
      try {
        rl.close();
      } catch {
        // Ignore cleanup errors
      }
    };

    rl.on('error', (error) => {
      cleanup();
      reject(error);
    });

    const options = ASSISTANT_CHOICES.map(formatAssistantName).join(' / ');

    rl.question(
      `Which assistant should we launch? (${options}): `,
      (answer) => {
        cleanup();
        const normalized = (answer || '').trim().toLowerCase();
        if (!normalized) {
          console.log('⚠️ No assistant selected. Please choose one.');
          return promptForAssistant().then(resolve).catch(reject);
        }

        if (ASSISTANT_CHOICES.includes(normalized)) {
          resolve(normalized);
          return;
        }

        console.log('⚠️ Unrecognized selection. Please try again.');
        return promptForAssistant().then(resolve).catch(reject);
      },
    );
  });

const determineAssistant = async (flagValue) => {
  if (flagValue) {
    if (ASSISTANT_CHOICES.includes(flagValue)) {
      return flagValue;
    }

    console.error('⚠️ Unsupported assistant flag value:', flagValue);
    console.error('Valid options:', ASSISTANT_CHOICES.join(', '));
    process.exit(1);
    return; // For testing when exit is mocked
  }

  if (!process.stdout.isTTY) {
    console.error(
      '⚠️ Non-interactive mode requires --assistant flag. Use: --assistant=claude|codex|opencode',
    );
    process.exit(1);
    return; // For testing when exit is mocked
  }

  return promptForAssistant();
};

// Command handlers
const commands = {
  start: async () => {
    console.log('🚀 Starting BMAD-invisible setup...\n');

    // Determine assistant preference before installation begins
    const { assistant: assistantFlag, sanitized } = parseAssistantFromArgs(args);
    args.splice(0, args.length, ...sanitized);
    const assistant = await determineAssistant(assistantFlag);

    // If assistant is undefined, exit was called (possibly mocked in tests)
    if (!assistant) {
      return;
    }

    if (process.stdout.isTTY) {
      console.log(
        '💡 We can optionally enable additional MCP servers (chrome-devtools, shadcn) during setup.',
      );
    }

    // Run init
    await commands.init();

    // Run npm install
    console.log('\n📦 Installing dependencies...\n');
    const install = spawn('npm', ['install'], {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: true,
    });

    await new Promise((resolve, reject) => {
      install.on('exit', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error('npm install failed'));
        }
      });
    });

    const assistantName = formatAssistantName(assistant);
    console.log(`\n🎯 Starting BMAD Invisible Orchestrator with ${assistantName}...\n`);

    if (assistant === 'claude') {
      await commands.chat();
      return;
    }

    if (assistant === 'opencode') {
      await commands.opencode();
      return;
    }

    await commands.codex();
  },

  init: async () => {
    console.log('🚀 Initializing BMAD-invisible...\n');

    const projectRoot = process.cwd();
    const packagePath = path.join(projectRoot, 'package.json');

    // Create package.json if it doesn't exist
    if (!fs.existsSync(packagePath)) {
      console.log('📦 Creating package.json...');
      const defaultPackage = {
        name: path.basename(projectRoot),
        version: '1.0.0',
        description: 'Project powered by BMAD-invisible',
        scripts: {},
        keywords: [],
        author: '',
        license: 'ISC',
      };
      fs.writeFileSync(packagePath, JSON.stringify(defaultPackage, null, 2) + '\n');
      console.log('✅ Created package.json');
    }

    // Create .bmad-invisible directory
    const bmadDir = path.join(projectRoot, '.bmad-invisible');
    if (!fs.existsSync(bmadDir)) {
      fs.mkdirSync(bmadDir, { recursive: true });
      console.log('✅ Created .bmad-invisible directory');
    }

    // Create .claude directory for MCP config
    const claudeDir = path.join(projectRoot, '.claude');
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
      console.log('✅ Created .claude directory');
    }

    // Create MCP config (inline template since we might be running from npx cache)
    const mcpConfigDest = path.join(claudeDir, 'mcp-config.json');
    let mcpConfig = { mcpServers: {} };
    let hadExistingMcpConfig = false;
    if (fs.existsSync(mcpConfigDest)) {
      try {
        const parsed = JSON.parse(fs.readFileSync(mcpConfigDest, 'utf8'));
        if (parsed && typeof parsed === 'object' && parsed.mcpServers) {
          // Preserve all top-level keys (logging, environment, etc.), not just mcpServers
          mcpConfig = { ...parsed };
          mcpConfig.mcpServers = { ...parsed.mcpServers };
          hadExistingMcpConfig = true;
        }
      } catch (error) {
        console.warn('⚠️ Failed to parse existing MCP configuration. Rebuilding from defaults.');
      }
    }

    const orchestratorKey = 'bmad-invisible-orchestrator';
    const orchestratorConfig = {
      command: 'node',
      args: ['${workspaceFolder}/node_modules/bmad-invisible/dist/mcp/mcp/server.js'],
      disabled: false,
    };

    if (!mcpConfig.mcpServers[orchestratorKey]) {
      mcpConfig.mcpServers[orchestratorKey] = orchestratorConfig;
      console.log('✅ Added BMAD-invisible orchestrator MCP server');
    } else {
      // Ensure orchestrator is enabled during re-init (user may have disabled it)
      mcpConfig.mcpServers[orchestratorKey].disabled = false;
    }

    const promptYesNo = async (question) => {
      if (!process.stdout.isTTY) {
        return false;
      }

      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        let cleanedUp = false;
        const cleanup = () => {
          if (cleanedUp) return;
          cleanedUp = true;
          try {
            rl.close();
          } catch {
            // ignore cleanup errors
          }
        };

        rl.on('error', (error) => {
          cleanup();
          reject(error);
        });

        rl.question(`${question} (y/N): `, (answer) => {
          cleanup();
          const normalized = (answer || '').trim().toLowerCase();
          resolve(normalized === 'y' || normalized === 'yes');
        });
      });
    };

    const optionalServerPromptsNeeded = OPTIONAL_MCP_SERVERS.filter(
      ({ id }) => !mcpConfig.mcpServers[id],
    );

    if (optionalServerPromptsNeeded.length > 0) {
      if (process.stdout.isTTY) {
        console.log('\n✨ Optional MCP servers available:');
        for (const server of optionalServerPromptsNeeded) {
          console.log(`   • ${server.label} — ${server.description}`);
        }
        console.log('');
      } else {
        console.log(
          'ℹ️ Optional MCP servers detected, but prompts are skipped in non-interactive mode.',
        );
      }
    }

    for (const optional of OPTIONAL_MCP_SERVERS) {
      if (mcpConfig.mcpServers[optional.id]) {
        continue;
      }

      let shouldAdd = false;
      try {
        shouldAdd = await promptYesNo(`Would you like to enable the ${optional.label}?`);
      } catch (error) {
        console.warn(
          `⚠️ Skipping ${optional.label} prompt due to an input error: ${error.message || error}`,
        );
      }

      if (shouldAdd) {
        mcpConfig.mcpServers[optional.id] = { ...optional.config };
        console.log(`✅ Added optional MCP server: ${optional.label}`);
      } else {
        console.log(`⏭️ Skipped optional MCP server: ${optional.label}`);
      }
    }

    fs.writeFileSync(mcpConfigDest, JSON.stringify(mcpConfig, null, 2) + '\n');
    console.log(
      hadExistingMcpConfig
        ? '✅ Updated MCP configuration with selected servers'
        : '✅ Created MCP configuration',
    );

    // Create docs directory
    const docsDir = path.join(projectRoot, 'docs');
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
      console.log('✅ Created docs directory');
    }

    // Create shadcn/ui configuration if it doesn't exist
    const componentsJsonPath = path.join(projectRoot, 'components.json');
    const shadcnConfig = {
      $schema: 'https://ui.shadcn.com/schema.json',
      style: 'new-york',
      rsc: true,
      tsx: true,
      tailwind: {
        config: 'tailwind.config.ts',
        css: 'app/globals.css',
        baseColor: 'zinc',
        cssVariables: true,
      },
      aliases: {
        components: '@/components',
        utils: '@/lib/utils',
      },
      registries: {
        '@originui': 'https://originui.com/r/components.json',
        '@aceternity': 'https://aceternity.com/r/components.json',
        '@magicui': 'https://magicui.design/r/components.json',
      },
    };

    if (fs.existsSync(componentsJsonPath)) {
      console.log('⚠️ components.json already exists. Skipping creation to avoid overwriting.');
    } else {
      fs.writeFileSync(componentsJsonPath, JSON.stringify(shadcnConfig, null, 2) + '\n');
      console.log('✅ Created shadcn UI config (components.json)');
    }

    // Add to package.json scripts
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    packageJson.scripts = packageJson.scripts || {};

    const scriptsToAdd = {
      codex: 'bmad-invisible codex',
      'bmad:codex': 'bmad-invisible codex',
      'bmad:chat': 'bmad-invisible chat',
      'bmad:build': 'bmad-invisible build',
    };

    let scriptsAdded = false;
    for (const [key, value] of Object.entries(scriptsToAdd)) {
      if (!packageJson.scripts[key]) {
        packageJson.scripts[key] = value;
        scriptsAdded = true;
      }
    }

    if (scriptsAdded) {
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added npm scripts to package.json');
    }

    // Add bmad-invisible as a dependency
    const needsInstall = !packageJson.dependencies || !packageJson.dependencies['bmad-invisible'];
    if (needsInstall) {
      packageJson.dependencies = packageJson.dependencies || {};
      packageJson.dependencies['bmad-invisible'] = '^1.0.0';
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added bmad-invisible to dependencies');
    }

    // Only create components.json if shadcn MCP server is enabled
    const shadcnEnabled = mcpConfig.mcpServers.shadcn && !mcpConfig.mcpServers.shadcn.disabled;
    if (shadcnEnabled) {
      const componentsPath = path.join(projectRoot, 'components.json');
      const shadcnConfig = {
        $schema: 'https://ui.shadcn.com/schema.json',
        style: 'default',
        rsc: false,
        tsx: true,
        tailwind: {
          config: 'tailwind.config.js',
          css: 'src/app/globals.css',
          baseColor: 'slate',
          cssVariables: true,
        },
        aliases: {
          components: '@/components',
          utils: '@/lib/utils',
        },
      };

      if (!fs.existsSync(componentsPath)) {
        fs.writeFileSync(componentsPath, JSON.stringify(shadcnConfig, null, 2) + '\n');
        console.log('✅ Created default shadcn components.json');
      } else {
        console.warn('⚠️ components.json already exists. Leaving the current configuration untouched.');
      }
    }

    console.log(`
✨ BMAD-invisible initialized successfully!

Next steps:
  1. Install dependencies:
     npm install


  2. Install Codex CLI if not already installed:
     https://platform.openai.com/docs/guides/codex

  3. Start chatting:
     npm run codex


For detailed documentation, visit:
  https://github.com/bacoco/BMAD-invisible
`);
  },

  codex: async () => {
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const codexScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'bmad-codex')
      : path.join(__dirname, 'bmad-codex');

    if (!fs.existsSync(codexScript)) {
      console.error('❌ BMAD-invisible not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx bmad-invisible init && npm install');
      process.exit(1);
    }

    const child = spawn('node', [codexScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Codex CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  chat: async () => {
    // Check if bmad-invisible is installed locally first
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const chatScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'bmad-claude')
      : path.join(__dirname, 'bmad-claude');

    if (!fs.existsSync(chatScript)) {
      console.error('❌ BMAD-invisible not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx bmad-invisible init && npm install');
      process.exit(1);
    }

    const child = spawn('node', [chatScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Claude CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  opencode: async () => {
    const child = spawn('opencode', args, {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: false,
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch OpenCode CLI:', error.message);
      console.error('   Make sure OpenCode is installed and in your PATH.');
      console.error('   Visit: https://github.com/openchatai/opencode for installation instructions');
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  install: async () => {
    console.log('📦 Installing BMAD-invisible globally...\n');

    const child = spawn('npm', ['install', '-g', 'bmad-invisible'], {
      stdio: 'inherit',
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n✅ BMAD-invisible installed globally!');
        console.log('You can now use: bmad-invisible <command>');
      }
      process.exit(code || 0);
    });
  },

  build: async () => {
    console.log('🔨 Building MCP server...\n');

    // Check if running from local install or global/npx
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const rootDir = fs.existsSync(localInstall) ? localInstall : path.join(__dirname, '..');

    // The MCP server is already pre-built in dist/, but we'll check TypeScript is available
    const distMcp = path.join(rootDir, 'dist', 'mcp', 'server.js');
    if (fs.existsSync(distMcp)) {
      console.log('✅ MCP server already built and ready!');
      console.log(`   Location: ${distMcp}`);
      return;
    }

    // If not found, try to build it
    const child = spawn('npm', ['run', 'build:mcp'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n✅ MCP server built successfully!');
      }
      process.exit(code || 0);
    });
  },

  test: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['test'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  validate: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['run', 'validate'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  help: () => {
    // Show help message
    printHelp();
  },
};

const setRuntimeContext = (nextCommand, nextArgs = []) => {
  command = nextCommand;
  args = Array.isArray(nextArgs) ? [...nextArgs] : [];
};

const run = (argv = process.argv) => {
  [, , command, ...args] = argv;

  if (!command || command === '--help' || command === '-h') {
    printHelp();
    return Promise.resolve();
  }

  const handler = commands[command];
  if (!handler) {
    console.error(`❌ Unknown command: ${command}`);
    console.log('Run "npx bmad-invisible help" for usage information.');
    process.exit(1);
  }

  try {
    const result = handler();
    if (result && typeof result.then === 'function') {
      return result.catch((error) => {
        console.error('❌ Error:', error.message);
        process.exit(1);
      });
    }

    return Promise.resolve(result);
  } catch (error) {
    console.error('❌ Error:', error.message);
    process.exit(1);
    return Promise.resolve();
  }
};

// Run integrity check only when executed directly (not when imported for testing)
// This ensures the CLI validates package integrity at runtime while allowing
// tests to import and mock functions without triggering validation
if (require.main === module) {
  runIntegrityPreflight(packageRoot, { silentOnMatch: true });

  run().catch((error) => {
    console.error('❌ Error:', error.message);
    process.exit(1);
  });
}

module.exports = {
  commands,
  determineAssistant,
  parseAssistantFromArgs,
  printHelp,
  run,
  runIntegrityPreflight,
  setRuntimeContext,
};
