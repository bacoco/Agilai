#!/usr/bin/env node

/**
 * BMAD Invisible - Main CLI entry point for npx deployment
 *
 * This executable provides easy installation and setup via:
 *   npx bmad-invisible init
 *   npx bmad-invisible chat
 *   npx bmad-invisible install
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

const [, , command, ...args] = process.argv;
const scriptFileName = path.basename(process.argv[1] || '');
const isCodexVariant = scriptFileName.includes('codex');
const chatLauncherName = isCodexVariant ? 'bmad-codex' : 'bmad-chat';
const cliDisplayName = isCodexVariant ? 'Codex CLI' : 'Claude Code CLI';
const packageCommand = isCodexVariant ? 'bmad-invisible-codex' : 'bmad-invisible';
const chatCommandLabel = isCodexVariant
  ? 'Start conversational interface (requires Codex CLI)'
  : 'Start conversational interface (requires Claude CLI)';
const startCommandSummary = isCodexVariant
  ? '🚀 ONE-COMMAND SETUP: init + install + codex chat (recommended!)'
  : '🚀 ONE-COMMAND SETUP: init + install + chat (recommended!)';
const chatScriptName = isCodexVariant ? 'bmad:codex' : 'bmad:chat';
const chatScriptValue = isCodexVariant ? 'bmad-invisible-codex chat' : 'bmad-invisible chat';
const startChatBanner = isCodexVariant
  ? '\\n🎯 Starting BMAD Invisible Orchestrator (Codex)...\\n'
  : '\\n🎯 Starting BMAD Invisible Orchestrator...\\n';

// Get current package version
const packageJsonPath = path.join(__dirname, '..', 'package.json');
const currentVersion = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')).version;

const printHelp = () => {
  console.log(`
BMAD Invisible - Zero-knowledge AI orchestration (v${currentVersion})

Usage:
  npx ${packageCommand}@latest <command> [options]

Commands:
  start                ${startCommandSummary}
  init                 Initialize BMAD-invisible in current project
  chat                 ${chatCommandLabel}
  install              Install BMAD-invisible globally
  build                Build MCP server
  test                 Run test suite
  validate             Validate configuration
  help                 Show this help message

Examples:
  npx ${packageCommand}@latest start      # 🚀 Do everything in one command!
  npx ${packageCommand}@latest init       # Setup in current project
  npm run ${chatScriptName}                    # Start conversation (after install)

Required tooling:
  - ${cliDisplayName} available on your PATH

💡 Tip: Always use @latest to get the newest version:
   npx ${packageCommand}@latest start

For more information: https://github.com/bacoco/BMAD-invisible
`);
};

// Show help if no command provided
if (!command || command === '--help' || command === '-h') {
  printHelp();
  process.exit(0);
}

// Command handlers
const commands = {
  start: async () => {
    console.log('🚀 Starting BMAD-invisible setup...\n');

    // Run init
    await commands.init();

    // Run npm install
    console.log('\n📦 Installing dependencies...\n');
    const install = spawn('npm', ['install'], {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: true,
    });

    await new Promise((resolve, reject) => {
      install.on('exit', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error('npm install failed'));
        }
      });
    });

    // Start chat
    console.log(startChatBanner);
    await commands.chat();
  },

  init: async () => {
    console.log('🚀 Initializing BMAD-invisible...\n');

    const projectRoot = process.cwd();
    const packagePath = path.join(projectRoot, 'package.json');

    // Create package.json if it doesn't exist
    if (!fs.existsSync(packagePath)) {
      console.log('📦 Creating package.json...');
      const defaultPackage = {
        name: path.basename(projectRoot),
        version: '1.0.0',
        description: 'Project powered by BMAD-invisible',
        scripts: {},
        keywords: [],
        author: '',
        license: 'ISC',
      };
      fs.writeFileSync(packagePath, JSON.stringify(defaultPackage, null, 2) + '\n');
      console.log('✅ Created package.json');
    }

    // Create .bmad-invisible directory
    const bmadDir = path.join(projectRoot, '.bmad-invisible');
    if (!fs.existsSync(bmadDir)) {
      fs.mkdirSync(bmadDir, { recursive: true });
      console.log('✅ Created .bmad-invisible directory');
    }

    // Create .claude directory for MCP config
    const claudeDir = path.join(projectRoot, '.claude');
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
      console.log('✅ Created .claude directory');
    }

    // Create MCP config (inline template since we might be running from npx cache)
    const mcpConfigDest = path.join(claudeDir, 'mcp-config.json');
    if (!fs.existsSync(mcpConfigDest)) {
      const mcpConfig = {
        mcpServers: {
          'bmad-invisible-orchestrator': {
            command: 'node',
            args: ['${workspaceFolder}/node_modules/bmad-invisible/dist/mcp/mcp/server.js'],
            disabled: false,
          },
        },
      };
      fs.writeFileSync(mcpConfigDest, JSON.stringify(mcpConfig, null, 2));
      console.log('✅ Created MCP configuration');
    }

    // Create docs directory
    const docsDir = path.join(projectRoot, 'docs');
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
      console.log('✅ Created docs directory');
    }

    // Add to package.json scripts
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    packageJson.scripts = packageJson.scripts || {};

    const scriptsToAdd = {
      'bmad:build': 'bmad-invisible build',
    };

    scriptsToAdd[chatScriptName] = chatScriptValue;

    let scriptsAdded = false;
    for (const [key, value] of Object.entries(scriptsToAdd)) {
      if (!packageJson.scripts[key]) {
        packageJson.scripts[key] = value;
        scriptsAdded = true;
      }
    }

    if (scriptsAdded) {
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added npm scripts to package.json');
    }

    // Add bmad-invisible as a dependency
    const needsInstall = !packageJson.dependencies || !packageJson.dependencies['bmad-invisible'];
    if (needsInstall) {
      packageJson.dependencies = packageJson.dependencies || {};
      packageJson.dependencies['bmad-invisible'] = '^1.0.0';
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added bmad-invisible to dependencies');
    }

    console.log(`
✨ BMAD-invisible initialized successfully!

Next steps:
  1. Install dependencies:
     npm install

  2. Install ${cliDisplayName} if not already installed:
     ${
       isCodexVariant
         ? 'Follow OpenAI Codex CLI installation instructions to add the `codex` command to your PATH'
         : 'npm install -g @anthropic-ai/claude-code'
     }

  3. Start chatting:
     npm run ${chatScriptName}

For detailed documentation, visit:
  https://github.com/bacoco/BMAD-invisible
`);
  },

  chat: async () => {
    // Check if bmad-invisible is installed locally first
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const chatScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', chatLauncherName)
      : path.join(__dirname, chatLauncherName);

    if (!fs.existsSync(chatScript)) {
      console.error('❌ BMAD-invisible not found. Please run "npm install" first.');
      console.error(`   Or initialize with: npx ${packageCommand} init && npm install`);
      process.exit(1);
    }

    const child = spawn('node', [chatScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  install: async () => {
    console.log('📦 Installing BMAD-invisible globally...\n');

    const child = spawn('npm', ['install', '-g', 'bmad-invisible'], {
      stdio: 'inherit',
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n✅ BMAD-invisible installed globally!');
        console.log(`You can now use: ${packageCommand} <command>`);
      }
      process.exit(code || 0);
    });
  },

  build: async () => {
    console.log('🔨 Building MCP server...\n');

    // Check if running from local install or global/npx
    const localInstall = path.join(process.cwd(), 'node_modules', 'bmad-invisible');
    const rootDir = fs.existsSync(localInstall) ? localInstall : path.join(__dirname, '..');

    // The MCP server is already pre-built in dist/, but we'll check TypeScript is available
    const distMcp = path.join(rootDir, 'dist', 'mcp', 'server.js');
    if (fs.existsSync(distMcp)) {
      console.log('✅ MCP server already built and ready!');
      console.log(`   Location: ${distMcp}`);
      return;
    }

    // If not found, try to build it
    const child = spawn('npm', ['run', 'build:mcp'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n✅ MCP server built successfully!');
      }
      process.exit(code || 0);
    });
  },

  test: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['test'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  validate: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['run', 'validate'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  help: () => {
    // Show help message
    printHelp();
  },
};

// Execute command
const handler = commands[command];
if (!handler) {
  console.error(`❌ Unknown command: ${command}`);
  console.log(`Run "npx ${packageCommand} help" for usage information.`);
  process.exit(1);
}

// Handle both sync and async commands
const result = handler();
if (result && typeof result.catch === 'function') {
  result.catch((error) => {
    console.error('❌ Error:', error.message);
    process.exit(1);
  });
}
