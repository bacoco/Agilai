#!/usr/bin/env node

/**
 * Agilai - Main CLI entry point for npx deployment
 *
 * This executable provides easy installation and setup via:
 *   npx agilai init
 *   npx agilai chat
 *   npx agilai install
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { runIntegrityPreflight } = require('../common/utils/integrity');
const { buildAssistantSpawnEnv } = require('../common/utils/assistant-env');

let command;
let args = [];
const packageRoot = path.join(__dirname, '..');

const CLAUDE_PROVIDER_ENV_KEYS = [
  'AGILAI_ASSISTANT_PROVIDER',
  'BMAD_ASSISTANT_PROVIDER',
  'CLAUDE_CLI_PROVIDER',
  'CLAUDE_CLI_DEFAULT_PROVIDER',
  'CLAUDE_DEFAULT_PROVIDER',
  'CLAUDE_PROVIDER',
  'CLAUDE_CODE_PROVIDER',
];

const GLM_API_KEY_ENV_KEYS = ['AGILAI_GLM_API_KEY', 'BMAD_GLM_API_KEY', 'GLM_API_KEY', 'ZHIPUAI_API_KEY'];
const GLM_BASE_URL_ENV_KEYS = ['AGILAI_GLM_BASE_URL', 'BMAD_GLM_BASE_URL', 'GLM_BASE_URL'];
const GLM_AUTH_TOKEN_ENV_KEYS = ['AGILAI_GLM_AUTH_TOKEN', 'BMAD_GLM_AUTH_TOKEN', 'GLM_AUTH_TOKEN'];

const hasOwn = (source, key) => Boolean(source && Object.prototype.hasOwnProperty.call(source, key));

/**
 * Resolves environment variable value from a prioritized list of keys
 * @param {Object} source - Environment object to search (e.g., process.env or parsed .env file)
 * @param {string[]} keys - Array of keys in priority order (first match wins)
 * @returns {{key: string|undefined, value: string|undefined}} The matched key and its trimmed value
 */
const resolveEnvValue = (source, keys) => {
  for (const key of keys) {
    const value = source?.[key];
    if (typeof value === 'string' && value.trim()) {
      return { key, value: value.trim() };
    }
  }

  return { key: undefined, value: undefined };
};

/**
 * Chooses which environment variable key to use for writing
 * Returns the first existing key from the source, or the first key if none exist
 * @param {Object} source - Environment object to check (e.g., parsed .env file)
 * @param {string[]} keys - Array of keys in priority order
 * @returns {string} The key to use for writing
 */
const chooseWriteKey = (source, keys) => {
  for (const key of keys) {
    if (hasOwn(source, key)) {
      return key;
    }
  }

  return keys[0];
};

/**
 * Sets a process environment variable only if it's not already set or is empty/whitespace
 * @param {string} key - The environment variable name
 * @param {string|undefined} value - The value to set (ignored if falsy or whitespace-only)
 */
const setProcessEnvIfMissing = (key, value) => {
  if (!value || (typeof value === 'string' && value.trim() === '')) {
    return;
  }

  if (typeof process.env[key] !== 'string' || process.env[key].trim() === '') {
    process.env[key] = value;
  }
};

const parseEnvFile = (filePath) => {
  const parsed = {};
  const raw = fs.readFileSync(filePath, 'utf8');
  const lines = raw.split(/\r?\n/);

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }

    const equalsIndex = trimmed.indexOf('=');
    if (equalsIndex === -1) {
      continue;
    }

    let key = trimmed.slice(0, equalsIndex).trim();
    if (key.startsWith('export ')) {
      key = key.slice('export '.length).trim();
    }

    if (!key) {
      continue;
    }

    let value = trimmed.slice(equalsIndex + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }

    // Validate that value doesn't contain newlines (would break .env format)
    if (value.includes('\n') || value.includes('\r')) {
      console.warn(`⚠️ Skipping invalid .env value for ${key}: contains newline characters`);
      continue;
    }

    parsed[key] = value;
  }

  return parsed;
};

const readProjectEnv = (projectRoot) => {
  const envPath = path.join(projectRoot, '.env');
  if (!fs.existsSync(envPath)) {
    return { values: {}, path: envPath };
  }

  try {
    return { values: parseEnvFile(envPath), path: envPath };
  } catch (error) {
    console.warn(
      `⚠️ Unable to parse ${envPath}: ${error.message || error}. Continuing without it.`,
    );
    return { values: {}, path: envPath };
  }
};

const isInteractiveTerminal = () => Boolean(process.stdin.isTTY && process.stdout.isTTY);

/**
 * Parses provider from CLI arguments.
 * Precedence: CLI args > process env vars > .env file > interactive prompts
 */
const parseProviderFromArgs = (cliArgs = []) => {
  for (let index = 0; index < cliArgs.length; index += 1) {
    const arg = cliArgs[index];

    if (arg === '--provider' || arg.startsWith('--provider=')) {
      const value = arg === '--provider' ? cliArgs[index + 1] : arg.split('=')[1];
      if (value && typeof value === 'string' && value.trim()) {
        return value.trim().toLowerCase();
      }
    }
  }

  return undefined;
};

const determineClaudeProvider = (cliArgs = [], envFromFile = {}) => {
  const fromArgs = parseProviderFromArgs(cliArgs);
  if (fromArgs) {
    return fromArgs;
  }

  for (const key of CLAUDE_PROVIDER_ENV_KEYS) {
    const value = process.env[key] || envFromFile[key];
    if (typeof value === 'string' && value.trim()) {
      return value.trim().toLowerCase();
    }
  }

  return undefined;
};

const promptForInput = (question) =>
  new Promise((resolve, reject) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    let cleanedUp = false;
    const cleanup = () => {
      if (cleanedUp) return;
      cleanedUp = true;
      try {
        rl.close();
      } catch {
        // Ignore cleanup errors
      }
    };

    // Timeout after 5 minutes to prevent hanging
    const timeout = setTimeout(() => {
      cleanup();
      reject(new Error('Input prompt timed out after 5 minutes'));
    }, 300000);

    rl.on('error', (error) => {
      clearTimeout(timeout);
      cleanup();
      reject(error);
    });

    rl.question(question, (answer) => {
      clearTimeout(timeout);
      cleanup();
      resolve(answer);
    });
  });

const promptForGlmCredentials = async ({ existingBaseUrl } = {}) => {
  console.log('🔐 GLM provider selected. A Z.AI API token is required.');

  let apiKey;
  while (!apiKey) {
    // eslint-disable-next-line no-await-in-loop
    const input = await promptForInput('Enter your Z.AI GLM API token: ');
    const trimmed = (input || '').trim();
    if (trimmed) {
      apiKey = trimmed;
    } else {
      console.log('⚠️ Token cannot be empty. Please provide a valid value.');
    }
  }

  const baseUrlPrompt = existingBaseUrl
    ? `Enter a custom GLM base URL (leave blank to keep ${existingBaseUrl}): `
    : 'Enter a custom GLM base URL (leave blank for the CLI default): ';
  const baseUrlInput = await promptForInput(baseUrlPrompt);
  const baseUrl = (baseUrlInput || '').trim();

  return { apiKey, baseUrl: baseUrl || undefined };
};

const promptToPersistGlmEnv = async () => {
  if (!isInteractiveTerminal()) {
    return false;
  }

  try {
    const answer = await promptForInput(
      'Would you like to save these GLM credentials to .env for future runs? (y/N): ',
    );
    const normalized = (answer || '').trim().toLowerCase();
    return normalized === 'y' || normalized === 'yes';
  } catch (error) {
    console.warn(
      `⚠️ Skipping persistence prompt due to an input error: ${error.message || error}`,
    );
    return false;
  }
};

const persistEnvValues = (envPath, updates) => {
  const normalizedUpdates = Object.entries(updates).reduce((acc, [key, value]) => {
    if (typeof value === 'string' && value) {
      // Validate no newlines in values
      if (value.includes('\n') || value.includes('\r')) {
        console.warn(`⚠️ Skipping ${key}: value contains newline characters`);
        return acc;
      }
      acc[key] = value;
    }
    return acc;
  }, {});

  const updateKeys = Object.keys(normalizedUpdates);
  if (updateKeys.length === 0) {
    return;
  }

  let lines = [];
  if (fs.existsSync(envPath)) {
    lines = fs.readFileSync(envPath, 'utf8').split(/\r?\n/);
  }

  const seenKeys = new Set();
  const updatedLines = lines.map((line) => {
    const match = line.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=(.*)$/);
    if (!match) {
      return line;
    }

    const key = match[1];
    if (Object.prototype.hasOwnProperty.call(normalizedUpdates, key)) {
      seenKeys.add(key);
      return `${key}=${normalizedUpdates[key]}`;
    }

    return line;
  });

  for (const key of updateKeys) {
    if (!seenKeys.has(key)) {
      updatedLines.push(`${key}=${normalizedUpdates[key]}`);
    }
  }

  const finalContent = updatedLines.join('\n') + '\n';

  fs.writeFileSync(envPath, finalContent);
  console.log('⚠️  WARNING: Keep this file secure and never commit it to version control.');
};

const ensureClaudeEnvironment = async ({ projectRoot, userArgs = [] }) => {
  const { values: fileEnv, path: envPath } = readProjectEnv(projectRoot);

  const anthropicToken = process.env.ANTHROPIC_AUTH_TOKEN || fileEnv.ANTHROPIC_AUTH_TOKEN;
  if (anthropicToken && !process.env.ANTHROPIC_AUTH_TOKEN) {
    process.env.ANTHROPIC_AUTH_TOKEN = anthropicToken;
  }

  const processApiKey = resolveEnvValue(process.env, GLM_API_KEY_ENV_KEYS);
  const fileApiKey = resolveEnvValue(fileEnv, GLM_API_KEY_ENV_KEYS);
  const processBaseUrl = resolveEnvValue(process.env, GLM_BASE_URL_ENV_KEYS);
  const fileBaseUrl = resolveEnvValue(fileEnv, GLM_BASE_URL_ENV_KEYS);
  const processAuthToken = resolveEnvValue(process.env, GLM_AUTH_TOKEN_ENV_KEYS);
  const fileAuthToken = resolveEnvValue(fileEnv, GLM_AUTH_TOKEN_ENV_KEYS);

  const glmApiKey = processApiKey.value || fileApiKey.value;
  const glmBaseUrl = processBaseUrl.value || fileBaseUrl.value;
  const glmAuthToken = processAuthToken.value || fileAuthToken.value;

  if (!processApiKey.value && fileApiKey.value) {
    setProcessEnvIfMissing(fileApiKey.key, fileApiKey.value);
  }

  if (!processBaseUrl.value && fileBaseUrl.value) {
    setProcessEnvIfMissing(fileBaseUrl.key, fileBaseUrl.value);
  }

  if (!processAuthToken.value && fileAuthToken.value) {
    setProcessEnvIfMissing(fileAuthToken.key, fileAuthToken.value);
  }

  setProcessEnvIfMissing('AGILAI_GLM_API_KEY', glmApiKey);
  setProcessEnvIfMissing('AGILAI_GLM_BASE_URL', glmBaseUrl);
  setProcessEnvIfMissing('AGILAI_GLM_AUTH_TOKEN', glmAuthToken);

  const legacyBmadApiKeyDetected = Boolean(process.env.BMAD_GLM_API_KEY || hasOwn(fileEnv, 'BMAD_GLM_API_KEY'));
  const legacyBmadBaseDetected = Boolean(process.env.BMAD_GLM_BASE_URL || hasOwn(fileEnv, 'BMAD_GLM_BASE_URL'));
  const legacyBmadAuthDetected = Boolean(process.env.BMAD_GLM_AUTH_TOKEN || hasOwn(fileEnv, 'BMAD_GLM_AUTH_TOKEN'));
  const legacyGlmApiKeyDetected = Boolean(process.env.GLM_API_KEY || hasOwn(fileEnv, 'GLM_API_KEY'));
  const legacyGlmBaseDetected = Boolean(process.env.GLM_BASE_URL || hasOwn(fileEnv, 'GLM_BASE_URL'));
  const legacyGlmAuthDetected = Boolean(process.env.GLM_AUTH_TOKEN || hasOwn(fileEnv, 'GLM_AUTH_TOKEN'));
  const legacyZhipuKeyDetected = Boolean(process.env.ZHIPUAI_API_KEY || hasOwn(fileEnv, 'ZHIPUAI_API_KEY'));

  if (legacyGlmApiKeyDetected) {
    setProcessEnvIfMissing('GLM_API_KEY', glmApiKey);
  }

  if (legacyGlmBaseDetected) {
    setProcessEnvIfMissing('GLM_BASE_URL', glmBaseUrl);
  }

  if (legacyGlmAuthDetected) {
    setProcessEnvIfMissing('GLM_AUTH_TOKEN', glmAuthToken);
  }

  if (legacyBmadApiKeyDetected) {
    setProcessEnvIfMissing('BMAD_GLM_API_KEY', glmApiKey);
  }

  if (legacyBmadBaseDetected) {
    setProcessEnvIfMissing('BMAD_GLM_BASE_URL', glmBaseUrl);
  }

  if (legacyBmadAuthDetected) {
    setProcessEnvIfMissing('BMAD_GLM_AUTH_TOKEN', glmAuthToken);
  }

  if (legacyZhipuKeyDetected) {
    setProcessEnvIfMissing('ZHIPUAI_API_KEY', glmApiKey);
  }

  const provider = determineClaudeProvider(userArgs, fileEnv);
  if (provider !== 'glm') {
    return;
  }

  const effectiveBaseUrl = glmBaseUrl;

  if (glmApiKey) {
    return;
  }

  if (!isInteractiveTerminal()) {
    console.error('❌ GLM provider selected but no GLM API key is configured.');
    console.error(
      '   Provide AGILAI_GLM_API_KEY (or legacy GLM_API_KEY / BMAD_GLM_API_KEY) and optional AGILAI_GLM_BASE_URL before running in non-interactive mode.',
    );
    process.exit(1);
  }

  let credentials;
  try {
    credentials = await promptForGlmCredentials({ existingBaseUrl: effectiveBaseUrl });
  } catch (error) {
    console.error('❌ Failed to read GLM credentials:', error.message || error);
    process.exit(1);
  }

  process.env.AGILAI_GLM_API_KEY = credentials.apiKey;
  if (legacyGlmApiKeyDetected && !process.env.GLM_API_KEY) {
    process.env.GLM_API_KEY = credentials.apiKey;
  }
  if (legacyBmadApiKeyDetected && !process.env.BMAD_GLM_API_KEY) {
    process.env.BMAD_GLM_API_KEY = credentials.apiKey;
  }
  if (legacyZhipuKeyDetected && !process.env.ZHIPUAI_API_KEY) {
    process.env.ZHIPUAI_API_KEY = credentials.apiKey;
  }

  if (credentials.baseUrl) {
    process.env.AGILAI_GLM_BASE_URL = credentials.baseUrl;
    if (legacyGlmBaseDetected && !process.env.GLM_BASE_URL) {
      process.env.GLM_BASE_URL = credentials.baseUrl;
    }
    if (legacyBmadBaseDetected && !process.env.BMAD_GLM_BASE_URL) {
      process.env.BMAD_GLM_BASE_URL = credentials.baseUrl;
    }
  } else if (effectiveBaseUrl) {
    setProcessEnvIfMissing('AGILAI_GLM_BASE_URL', effectiveBaseUrl);
    if (legacyGlmBaseDetected) {
      setProcessEnvIfMissing('GLM_BASE_URL', effectiveBaseUrl);
    }
    if (legacyBmadBaseDetected) {
      setProcessEnvIfMissing('BMAD_GLM_BASE_URL', effectiveBaseUrl);
    }
  }

  if (glmAuthToken) {
    setProcessEnvIfMissing('AGILAI_GLM_AUTH_TOKEN', glmAuthToken);
  }

  const shouldPersist = await promptToPersistGlmEnv();
  if (!shouldPersist) {
    console.log('ℹ️ Skipped saving GLM credentials to .env.');
    return;
  }

  const updates = {};
  updates[chooseWriteKey(fileEnv, GLM_API_KEY_ENV_KEYS)] = credentials.apiKey;
  const baseToPersist = credentials.baseUrl || effectiveBaseUrl;
  if (baseToPersist) {
    updates[chooseWriteKey(fileEnv, GLM_BASE_URL_ENV_KEYS)] = baseToPersist;
  }

  try {
    persistEnvValues(envPath, updates);
    const relativeEnvPath = path.relative(process.cwd(), envPath) || '.env';
    console.log(`💾 Saved GLM credentials to ${relativeEnvPath}`);
  } catch (error) {
    console.warn(`⚠️ Unable to persist GLM credentials: ${error.message || error}`);
  }
};

const createDefaultRuntimeOptions = () => ({
  llmProvider: undefined,
  llmModel: undefined,
});

let runtimeOptions = createDefaultRuntimeOptions();

const VALID_LLM_PROVIDERS = new Set(['claude', 'glm', 'openai', 'gpt', 'gemini', 'google']);

const normalizeLlmProvider = (value) => {
  if (!value) {
    return undefined;
  }

  const normalized = value.toLowerCase();

  if (normalized === 'anthropic') {
    return 'claude';
  }

  if (normalized === 'zhipu') {
    return 'glm';
  }

  return normalized;
};

const parseLlmOptionsFromArgs = (currentArgs) => {
  let provider;
  let model;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--glm') {
      provider = 'glm';
      continue;
    }

    if (arg === '--anthropic') {
      provider = 'claude';
      continue;
    }

    if (arg === '--llm-provider') {
      provider = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--llm-provider=')) {
      provider = arg.split('=')[1];
      continue;
    }

    if (arg === '--llm-model') {
      model = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--llm-model=')) {
      model = arg.split('=')[1];
      continue;
    }

    sanitized.push(arg);
  }

  return { provider: normalizeLlmProvider(provider), model, sanitized };
};

const consumeLlmOptionsFromArgs = () => {
  if (!args.length) {
    return;
  }

  const { provider, model, sanitized } = parseLlmOptionsFromArgs(args);
  args.splice(0, args.length, ...sanitized);

  if (provider) {
    if (!VALID_LLM_PROVIDERS.has(provider)) {
      console.error('⚠️ Unsupported LLM provider flag value:', provider);
      console.error('Valid providers:', Array.from(VALID_LLM_PROVIDERS).join(', '));
      process.exit(1);
      return;
    }

    runtimeOptions.llmProvider = provider;
  }

  if (model) {
    runtimeOptions.llmModel = model;
  }
};

const buildSpawnEnv = () => {
  const env = { ...process.env };
  const legacyBmadProviderDetected = typeof process.env.BMAD_ASSISTANT_PROVIDER === 'string';
  const legacyBmadApiKeyDetected = typeof process.env.BMAD_GLM_API_KEY === 'string';
  const legacyBmadBaseDetected = typeof process.env.BMAD_GLM_BASE_URL === 'string';
  const legacyBmadAuthDetected = typeof process.env.BMAD_GLM_AUTH_TOKEN === 'string';
  const legacyGlmApiKeyDetected = typeof process.env.GLM_API_KEY === 'string';
  const legacyGlmBaseDetected = typeof process.env.GLM_BASE_URL === 'string';
  const legacyGlmAuthDetected = typeof process.env.GLM_AUTH_TOKEN === 'string';
  const legacyZhipuKeyDetected = typeof process.env.ZHIPUAI_API_KEY === 'string';

  if (runtimeOptions.llmProvider) {
    env.LLM_PROVIDER = runtimeOptions.llmProvider;
    env.AGILAI_ASSISTANT_PROVIDER = runtimeOptions.llmProvider;

    if (legacyBmadProviderDetected) {
      env.BMAD_ASSISTANT_PROVIDER = runtimeOptions.llmProvider;
    } else if (env.BMAD_ASSISTANT_PROVIDER === 'glm') {
      delete env.BMAD_ASSISTANT_PROVIDER;
    }

    if (runtimeOptions.llmProvider === 'glm') {
      const existingKey =
        env.AGILAI_GLM_API_KEY || env.BMAD_GLM_API_KEY || env.GLM_API_KEY || env.ZHIPUAI_API_KEY;
      const existingBase =
        env.AGILAI_GLM_BASE_URL || env.BMAD_GLM_BASE_URL || env.GLM_BASE_URL;
      const existingAuth =
        env.AGILAI_GLM_AUTH_TOKEN || env.BMAD_GLM_AUTH_TOKEN || env.GLM_AUTH_TOKEN;

      if (existingKey && !env.AGILAI_GLM_API_KEY) {
        env.AGILAI_GLM_API_KEY = existingKey;
      }
      if (existingBase && !env.AGILAI_GLM_BASE_URL) {
        env.AGILAI_GLM_BASE_URL = existingBase;
      }
      if (existingAuth && !env.AGILAI_GLM_AUTH_TOKEN) {
        env.AGILAI_GLM_AUTH_TOKEN = existingAuth;
      }

      if (legacyGlmApiKeyDetected && !env.GLM_API_KEY && existingKey) {
        env.GLM_API_KEY = existingKey;
      }
      if (legacyGlmBaseDetected && !env.GLM_BASE_URL && existingBase) {
        env.GLM_BASE_URL = existingBase;
      }
      if (legacyGlmAuthDetected && !env.GLM_AUTH_TOKEN && existingAuth) {
        env.GLM_AUTH_TOKEN = existingAuth;
      }

      if (legacyBmadApiKeyDetected && !env.BMAD_GLM_API_KEY && existingKey) {
        env.BMAD_GLM_API_KEY = existingKey;
      }
      if (legacyBmadBaseDetected && !env.BMAD_GLM_BASE_URL && existingBase) {
        env.BMAD_GLM_BASE_URL = existingBase;
      }
      if (legacyBmadAuthDetected && !env.BMAD_GLM_AUTH_TOKEN && existingAuth) {
        env.BMAD_GLM_AUTH_TOKEN = existingAuth;
      }

      if (legacyZhipuKeyDetected && !env.ZHIPUAI_API_KEY && existingKey) {
        env.ZHIPUAI_API_KEY = existingKey;
      }
    }
  }

  if (runtimeOptions.llmModel) {
    env.LLM_MODEL = runtimeOptions.llmModel;
  }

  return env;
};

// Get current package version
const packageJsonPath = path.join(__dirname, '..', 'package.json');
const currentVersion = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')).version;

const printHelp = () => {
  console.log(`
Agilai - Zero-knowledge AI orchestration (v${currentVersion})

Usage:
  npx agilai@latest <command> [options]

Options:
  --assistant=<assistant>    Launch specified CLI front-end (claude, codex, opencode)
  --llm-provider=<provider>  Override orchestrator LLM (claude, glm, openai, gemini)
  --llm-model=<model>        Force a specific model id for the orchestrator
  --glm                      Shortcut for --llm-provider=glm (uses ZHIPUAI_API_KEY)
  --anthropic                Shortcut for --llm-provider=claude

Commands:

  start                🚀 ONE-COMMAND SETUP: init + install + prompt for assistant choice
  init                 Initialize Agilai in current project
  chat                 Start conversational interface with Claude CLI (Anthropic/GLM)
  codex                Start conversational interface with Codex CLI
  opencode             Start conversational interface with OpenCode CLI

  install              Install Agilai globally
  build                Build MCP server
  test                 Run test suite
  validate             Validate configuration
  help                 Show this help message

Examples:

  npx agilai@latest start      # 🚀 Do everything in one command!
  npx agilai@latest start --assistant=claude --provider=glm
                                      # Skip prompts & launch Claude with GLM
  npx agilai@latest start --assistant=claude-glm
                                      # Combined flag also supported
  npx agilai@latest start --assistant=opencode
                                      # Skip the prompt and launch OpenCode
  npx agilai@latest start --glm
                                      # Use GLM with AGILAI_GLM_API_KEY (preferred)
  npx agilai@latest init       # Setup in current project
  npm run codex                        # Start conversation (after install)


Flags:
  Use --assistant and optionally --provider to skip prompts. Combine values like
  --assistant=claude-glm when preferred.


💡 Tip: Always use @latest to get the newest version:
   npx agilai@latest start

Environment:
  Set AGILAI_GLM_API_KEY (preferred) or legacy GLM_API_KEY/ZHIPUAI_API_KEY and optionally LLM_MODEL when using --glm.
  Use --anthropic or LLM_PROVIDER=claude to switch back to Anthropic defaults.

For more information: https://github.com/bacoco/Agilai
`);
};

const ASSISTANT_CHOICES = [
  {
    id: 'claude',
    providers: ['anthropic', 'glm'],
  },
  {
    id: 'codex',
    providers: ['anthropic'],
  },
  {
    id: 'opencode',
    providers: ['anthropic'],
  },
];

const findAssistantChoice = (id) =>
  ASSISTANT_CHOICES.find((choice) => choice.id === id);

const listAssistantIds = () => ASSISTANT_CHOICES.map(({ id }) => id);

const splitAssistantAndProvider = (value) => {
  if (!value) {
    return { assistant: undefined, provider: undefined };
  }

  const normalized = value.toLowerCase();
  const [assistantPart, ...providerParts] = normalized.split('-');
  const provider = providerParts.length > 0 ? providerParts.join('-') : undefined;

  return {
    assistant: assistantPart,
    provider,
  };
};

const OPTIONAL_MCP_SERVERS = [
  {
    id: 'chrome-devtools',
    label: 'Chrome DevTools bridge',
    description: 'Inspect and control active Chrome tabs via the DevTools protocol.',
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-chrome-devtools'],
      disabled: false,
    },
  },
  {
    id: 'shadcn',
    label: 'shadcn/ui component generator',
    description: 'Generate UI components from the shadcn library.',
    config: {
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-shadcn'],
      disabled: false,
    },
  },
  {
    id: 'gitmcp',
    label: 'Git repository operations',
    description: 'Git operations and version control via MCP.',
    config: {
      command: 'npx',
      args: ['-y', 'gitmcp'],
      disabled: false,
    },
  },
];

const formatAssistantName = (value) =>
  value.charAt(0).toUpperCase() + value.slice(1);

const parseAssistantFromArgs = (currentArgs) => {
  let assistant;
  let provider;
  let providerExplicit = false;
  const sanitized = [];

  for (let index = 0; index < currentArgs.length; index += 1) {
    const arg = currentArgs[index];

    if (arg === '--assistant') {
      assistant = currentArgs[index + 1];
      index += 1;
      continue;
    }

    if (arg.startsWith('--assistant=')) {
      assistant = arg.split('=')[1];
      continue;
    }

    if (arg === '--provider') {
      provider = currentArgs[index + 1];
      index += 1;
      providerExplicit = true;
      continue;
    }

    if (arg.startsWith('--provider=')) {
      provider = arg.split('=')[1];
      providerExplicit = true;
      continue;
    }

    sanitized.push(arg);
  }

  if (assistant) {
    const { assistant: parsedAssistant, provider: combinedProvider } =
      splitAssistantAndProvider(assistant);
    assistant = parsedAssistant;
    if (!provider && combinedProvider) {
      provider = combinedProvider;
      providerExplicit = true;
    }
  }

  return {
    assistant: assistant ? assistant.toLowerCase() : undefined,
    provider: provider ? provider.toLowerCase() : undefined,
    providerExplicit,
    sanitized,
  };
};

const promptForAssistant = async () => {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const askQuestion = (prompt) =>
    new Promise((resolve, reject) => {
      const handleError = (error) => {
        rl.removeListener('error', handleError);
        reject(error);
      };

      rl.once('error', handleError);
      rl.question(prompt, (answer) => {
        rl.removeListener('error', handleError);
        resolve(answer);
      });
    });

  try {
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const options = ASSISTANT_CHOICES.map((choice) => {
        const providersLabel =
          choice.providers.length > 1
            ? ` (${choice.providers.join('/')})`
            : '';
        return `${formatAssistantName(choice.id)}${providersLabel}`;
      }).join(' / ');

      const answer = (await askQuestion(
        `Which assistant should we launch? (${options}): `,
      ))
        .trim()
        .toLowerCase();

      if (!answer) {
        console.log('⚠️ No assistant selected. Please choose one.');
        continue;
      }

      const { assistant: selectedAssistant, provider: embeddedProvider } =
        splitAssistantAndProvider(answer);
      const choice = findAssistantChoice(selectedAssistant);

      if (!choice) {
        console.log('⚠️ Unrecognized selection. Please try again.');
        continue;
      }

      let provider = embeddedProvider;
      let providerExplicit = Boolean(embeddedProvider);

      if (provider && !choice.providers.includes(provider)) {
        console.log('⚠️ Unsupported provider for that assistant. Please try again.');
        continue;
      }

      if (!provider) {
        if (choice.providers.length === 1) {
          provider = choice.providers[0];
        } else {
          const providerAnswer = (await askQuestion(
            `Which provider should power ${formatAssistantName(choice.id)}? (${choice.providers.join(
              '/',
            )}): `,
          ))
            .trim()
            .toLowerCase();

          if (!providerAnswer) {
            console.log('⚠️ No provider selected. Please try again.');
            continue;
          }

          if (!choice.providers.includes(providerAnswer)) {
            console.log('⚠️ Unsupported provider. Please try again.');
            continue;
          }

          provider = providerAnswer;
          providerExplicit = true;
        }
      }

      return { assistant: choice.id, provider, providerExplicit };
    }
  } finally {
    try {
      rl.close();
    } catch {
      // Ignore cleanup errors
    }
  }
};

const determineAssistant = async (input = {}) => {
  if (typeof input === 'string' || input === undefined) {
    return determineAssistant({ assistant: input });
  }

  const { assistant: assistantFlag, provider: providerFlag, providerExplicit: providerExplicitFromInput } = input;
  if (assistantFlag) {
    const { assistant: normalizedAssistant, provider: combinedProvider } =
      splitAssistantAndProvider(assistantFlag);
    let provider = providerFlag || combinedProvider;
    let providerExplicit =
      Boolean(providerFlag) || (combinedProvider ? providerExplicitFromInput !== false : false);
    const choice = findAssistantChoice(normalizedAssistant);

    if (!choice) {
      console.error('⚠️ Unsupported assistant flag value:', assistantFlag);
      console.error('Valid options:', listAssistantIds().join(', '));
      process.exit(1);
      return; // For testing when exit is mocked
    }

    if (provider && !choice.providers.includes(provider)) {
      console.error(
        `⚠️ Unsupported provider "${provider}" for assistant "${normalizedAssistant}".`,
      );
      console.error(
        `Valid providers for ${normalizedAssistant}: ${choice.providers.join(', ')}`,
      );
      process.exit(1);
      return; // For testing when exit is mocked
    }

    if (!provider) {
      [provider] = choice.providers;
      providerExplicit = false;
    }

    return { assistant: choice.id, provider, providerExplicit };
  }

  if (!process.stdout.isTTY) {
    console.error(
      '⚠️ Non-interactive mode requires --assistant flag. Use: --assistant=claude, --assistant=claude-glm, or combine with --provider.',
    );
    process.exit(1);
    return; // For testing when exit is mocked
  }

  return promptForAssistant();
};

// Command handlers
const commands = {
  start: async () => {
    console.log('🚀 Starting Agilai setup...\n');

    consumeLlmOptionsFromArgs();

    // Determine assistant preference before installation begins
    const {
      assistant: assistantFlag,
      provider: providerFlag,
      providerExplicit,
      sanitized,
    } = parseAssistantFromArgs(args);
    args.splice(0, args.length, ...sanitized);
    const selection = await determineAssistant({
      assistant: assistantFlag,
      provider: providerFlag,
      providerExplicit,
    });

    // If selection is undefined, exit was called (possibly mocked in tests)
    if (!selection) {
      return;
    }

      const {
        assistant,
        provider,
        providerExplicit: providerWasExplicit,
      } = selection;
      const choice = findAssistantChoice(assistant);
      let resolvedProvider = provider;

    // Override provider to GLM when --glm flag is used, the assistant supports GLM,
    // and the user didn't explicitly select a different provider via --provider flag
    if (
      runtimeOptions.llmProvider === 'glm' &&
      choice?.providers.includes('glm') &&
      resolvedProvider !== 'glm' &&
        !providerWasExplicit
      ) {
        resolvedProvider = 'glm';
      }

    process.env.AGILAI_ASSISTANT_PROVIDER = resolvedProvider;
    if (process.env.BMAD_ASSISTANT_PROVIDER) {
      process.env.BMAD_ASSISTANT_PROVIDER = resolvedProvider;
    }

    if (process.stdout.isTTY) {
      console.log(
        '💡 We can optionally enable additional MCP servers (chrome-devtools, shadcn) during setup.',
      );
    }

    // Run init
    await commands.init();

    // Run npm install
    console.log('\n📦 Installing dependencies...\n');
    const install = spawn('npm', ['install'], {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: true,
    });

    await new Promise((resolve, reject) => {
      install.on('exit', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error('npm install failed'));
        }
      });
    });

    const assistantName = formatAssistantName(assistant);
    const providerLabel = resolvedProvider ? ` (${resolvedProvider})` : '';
    console.log(
      `\n🎯 Starting Agilai Orchestrator with ${assistantName}${providerLabel}...\n`,
    );

    if (assistant === 'claude') {
      await commands.chat();
      return;
    }

    if (assistant === 'opencode') {
      await commands.opencode();
      return;
    }

    await commands.codex();
  },

  init: async () => {
    console.log('🚀 Initializing Agilai...\n');

    const projectRoot = process.cwd();
    const packagePath = path.join(projectRoot, 'package.json');

    // Create package.json if it doesn't exist
    if (!fs.existsSync(packagePath)) {
      console.log('📦 Creating package.json...');
      const defaultPackage = {
        name: path.basename(projectRoot),
        version: '1.0.0',
        description: 'Project powered by Agilai',
        scripts: {},
        keywords: [],
        author: '',
        license: 'ISC',
      };
      fs.writeFileSync(packagePath, JSON.stringify(defaultPackage, null, 2) + '\n');
      console.log('✅ Created package.json');
    }

    // Create .agilai directory
    const agilaiDir = path.join(projectRoot, '.agilai');
    if (!fs.existsSync(agilaiDir)) {
      fs.mkdirSync(agilaiDir, { recursive: true });
      console.log('✅ Created .agilai directory');
    }

    // Create .claude directory for MCP config
    const claudeDir = path.join(projectRoot, '.claude');
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
      console.log('✅ Created .claude directory');
    }

    // Create MCP config (inline template since we might be running from npx cache)
    // Use .mcp.json in project root for better Claude CLI compatibility
    const mcpConfigDest = path.join(projectRoot, '.mcp.json');
    let mcpConfig = { mcpServers: {} };
    let hadExistingMcpConfig = false;
    if (fs.existsSync(mcpConfigDest)) {
      try {
        const parsed = JSON.parse(fs.readFileSync(mcpConfigDest, 'utf8'));
        if (parsed && typeof parsed === 'object' && parsed.mcpServers) {
          // Preserve all top-level keys (logging, environment, etc.), not just mcpServers
          mcpConfig = { ...parsed };
          mcpConfig.mcpServers = { ...parsed.mcpServers };
          hadExistingMcpConfig = true;
        }
      } catch (error) {
        console.warn('⚠️ Failed to parse existing MCP configuration. Rebuilding from defaults.');
      }
    }

    const orchestratorKey = 'agilai-invisible-orchestrator';
    const orchestratorConfig = {
      command: 'node',
      args: ['-e', "require(require('path').resolve(__dirname, 'dist','mcp','mcp','server.js'))"],
      disabled: false,
    };

    if (!mcpConfig.mcpServers[orchestratorKey]) {
      mcpConfig.mcpServers[orchestratorKey] = orchestratorConfig;
      console.log('✅ Added Agilai orchestrator MCP server');
    } else {
      // Ensure orchestrator is enabled during re-init (user may have disabled it)
      mcpConfig.mcpServers[orchestratorKey].disabled = false;
    }

    const promptYesNo = async (question) => {
      if (!process.stdout.isTTY) {
        return false;
      }

      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        let cleanedUp = false;
        const cleanup = () => {
          if (cleanedUp) return;
          cleanedUp = true;
          try {
            rl.close();
          } catch {
            // ignore cleanup errors
          }
        };

        rl.on('error', (error) => {
          cleanup();
          reject(error);
        });

        rl.question(`${question} (y/N): `, (answer) => {
          cleanup();
          const normalized = (answer || '').trim().toLowerCase();
          resolve(normalized === 'y' || normalized === 'yes');
        });
      });
    };

    const optionalServerPromptsNeeded = OPTIONAL_MCP_SERVERS.filter(
      ({ id }) => !mcpConfig.mcpServers[id],
    );

    if (optionalServerPromptsNeeded.length > 0) {
      if (process.stdout.isTTY) {
        console.log('\n✨ Optional MCP servers available:');
        for (const server of optionalServerPromptsNeeded) {
          console.log(`   • ${server.label} — ${server.description}`);
        }
        console.log('');
      } else {
        console.log(
          'ℹ️ Optional MCP servers detected, but prompts are skipped in non-interactive mode.',
        );
      }
    }

    for (const optional of OPTIONAL_MCP_SERVERS) {
      if (mcpConfig.mcpServers[optional.id]) {
        continue;
      }

      let shouldAdd = false;
      try {
        shouldAdd = await promptYesNo(`Would you like to enable the ${optional.label}?`);
      } catch (error) {
        console.warn(
          `⚠️ Skipping ${optional.label} prompt due to an input error: ${error.message || error}`,
        );
      }

      if (shouldAdd) {
        mcpConfig.mcpServers[optional.id] = { ...optional.config };
        console.log(`✅ Added optional MCP server: ${optional.label}`);
      } else {
        console.log(`⏭️ Skipped optional MCP server: ${optional.label}`);
      }
    }

    fs.writeFileSync(mcpConfigDest, JSON.stringify(mcpConfig, null, 2) + '\n');
    console.log(
      hadExistingMcpConfig
        ? '✅ Updated MCP configuration with selected servers'
        : '✅ Created MCP configuration',
    );

    // Create docs directory
    const docsDir = path.join(projectRoot, 'docs');
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
      console.log('✅ Created docs directory');
    }

    // Add to package.json scripts
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    packageJson.scripts = packageJson.scripts || {};

    const scriptsToAdd = {
      agilai: 'agilai start',
      codex: 'agilai codex',
      'agilai:codex': 'agilai codex',
      'agilai:claude': 'agilai chat',
      'agilai:opencode': 'agilai opencode',
      'agilai:build': 'agilai build',
    };

    let scriptsAdded = false;
    for (const [key, value] of Object.entries(scriptsToAdd)) {
      if (!packageJson.scripts[key]) {
        packageJson.scripts[key] = value;
        scriptsAdded = true;
      }
    }

    if (scriptsAdded) {
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log('✅ Added npm scripts to package.json');
    }

    // Add agilai as a dependency
    const desiredDependencyVersion = `^${currentVersion}`;
    const existingDependencyVersion =
      packageJson.dependencies && packageJson.dependencies.agilai;
    const needsDependencyUpdate = existingDependencyVersion !== desiredDependencyVersion;

    if (needsDependencyUpdate) {
      packageJson.dependencies = packageJson.dependencies || {};
      packageJson.dependencies.agilai = desiredDependencyVersion;
      fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
      console.log(`✅ Ensured agilai@${desiredDependencyVersion} is listed in dependencies`);
    }

    // Only create components.json if shadcn MCP server is enabled
    const shadcnEnabled = mcpConfig.mcpServers.shadcn && !mcpConfig.mcpServers.shadcn.disabled;
    if (shadcnEnabled) {
      const componentsPath = path.join(projectRoot, 'components.json');

      // Auto-detect project configuration for smart defaults
      const detectProjectConfig = () => {
        const config = {
          cssPath: 'app/globals.css',
          tailwindConfig: 'tailwind.config.ts',
          useTsx: true,
          useRsc: true,
        };

        // Detect CSS location (common Next.js paths)
        const cssCandidates = [
          'app/globals.css',
          'src/app/globals.css',
          'styles/globals.css',
          'src/styles/globals.css',
        ];
        for (const candidate of cssCandidates) {
          if (fs.existsSync(path.join(projectRoot, candidate))) {
            config.cssPath = candidate;
            break;
          }
        }

        // Detect Tailwind config variant (.ts vs .js)
        if (fs.existsSync(path.join(projectRoot, 'tailwind.config.js'))) {
          config.tailwindConfig = 'tailwind.config.js';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.cjs'))) {
          config.tailwindConfig = 'tailwind.config.cjs';
        } else if (fs.existsSync(path.join(projectRoot, 'tailwind.config.mjs'))) {
          config.tailwindConfig = 'tailwind.config.mjs';
        }
        // Default to .ts if nothing found (assume TypeScript project)

        // Detect TypeScript usage
        const hasTsConfig = fs.existsSync(path.join(projectRoot, 'tsconfig.json'));
        const hasTypeScriptDep = fs.existsSync(packagePath) &&
          (() => {
            try {
              const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
              return (pkg.dependencies && pkg.dependencies.typescript) ||
                     (pkg.devDependencies && pkg.devDependencies.typescript);
            } catch {
              return false;
            }
          })();
        config.useTsx = hasTsConfig || hasTypeScriptDep;

        // Detect Next.js App Router vs Pages Router for RSC
        const hasAppDir = fs.existsSync(path.join(projectRoot, 'app')) ||
                         fs.existsSync(path.join(projectRoot, 'src/app'));
        const hasPagesDir = fs.existsSync(path.join(projectRoot, 'pages')) ||
                           fs.existsSync(path.join(projectRoot, 'src/pages'));
        config.useRsc = hasAppDir || !hasPagesDir; // Default to RSC unless Pages Router is clearly used

        return config;
      };

      // Validate shadcn prerequisites
      const validateShadcnPrerequisites = () => {
        const warnings = [];

        try {
          const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
          const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };

          // Check for Next.js (shadcn primarily targets Next.js)
          if (!allDeps.next && !allDeps.react) {
            warnings.push('Neither Next.js nor React detected. shadcn components require React.');
          }

          // Check for Tailwind CSS
          if (!allDeps.tailwindcss) {
            warnings.push('Tailwind CSS not detected. shadcn components require Tailwind CSS.');
          }
        } catch {
          // If we can't read package.json, skip validation (it was just created)
        }

        return warnings;
      };

      const detectedConfig = detectProjectConfig();
      const validationWarnings = validateShadcnPrerequisites();

      // Show validation warnings if any
      if (validationWarnings.length > 0) {
        console.warn('\n⚠️ shadcn prerequisites check:');
        for (const warning of validationWarnings) {
          console.warn(`   • ${warning}`);
        }
        console.warn('   You may need to install these dependencies for shadcn to work properly.\n');
      }

      const shadcnConfig = {
        $schema: 'https://ui.shadcn.com/schema.json',
        style: 'new-york',
        rsc: detectedConfig.useRsc,
        tsx: detectedConfig.useTsx,
        tailwind: {
          config: detectedConfig.tailwindConfig,
          css: detectedConfig.cssPath,
          baseColor: 'zinc',
          cssVariables: true,
        },
        aliases: {
          components: '@/components',
          utils: '@/lib/utils',
        },
        registries: {
          '@originui': 'https://originui.com/r/components.json',
          '@aceternity': 'https://aceternity.com/r/components.json',
          '@magicui': 'https://magicui.design/r/components.json',
        },
      };

      if (!fs.existsSync(componentsPath)) {
        fs.writeFileSync(componentsPath, JSON.stringify(shadcnConfig, null, 2) + '\n');
        console.log('✅ Created shadcn components.json (New York preset)');
        if (detectedConfig.cssPath !== 'app/globals.css' ||
            detectedConfig.tailwindConfig !== 'tailwind.config.ts') {
          console.log(`   📍 Detected paths: ${detectedConfig.cssPath}, ${detectedConfig.tailwindConfig}`);
        }
      } else {
        console.warn('⚠️ components.json already exists. Leaving the current shadcn configuration untouched.');
      }
    } else {
      console.log('ℹ️ Skipped shadcn components.json creation (shadcn MCP server disabled).');
    }

    console.log(`
✨ Agilai initialized successfully!

Next steps:
  1. Install dependencies:
     npm install


  2. Install Codex CLI if not already installed:
     https://platform.openai.com/docs/guides/codex

  3. Start chatting:
     npm run agilai:codex


For detailed documentation, visit:
  https://github.com/bacoco/Agilai
`);
  },

  codex: async () => {
    consumeLlmOptionsFromArgs();

    const localInstall = path.join(process.cwd(), 'node_modules', 'agilai');
    const codexScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'agilai-codex')
      : path.join(__dirname, 'agilai-codex');

    if (!fs.existsSync(codexScript)) {
      console.error('❌ Agilai not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx agilai init && npm install');
      process.exit(1);
    }

    const child = spawn('node', [codexScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
      env: buildSpawnEnv(),
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Codex CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  chat: async () => {
    consumeLlmOptionsFromArgs();

    // Check if agilai is installed locally first
    const localInstall = path.join(process.cwd(), 'node_modules', 'agilai');
    const chatScript = fs.existsSync(localInstall)
      ? path.join(localInstall, 'bin', 'agilai-claude')
      : path.join(__dirname, 'agilai-claude');

    if (!fs.existsSync(chatScript)) {
      console.error('❌ Agilai not found. Please run "npm install" first.');
      console.error('   Or initialize with: npx agilai init && npm install');
      process.exit(1);
    }

    await ensureClaudeEnvironment({ projectRoot: process.cwd(), userArgs: args });

    // Merge runtime LLM flags with Anthropic-compatible GLM env when active
    const baseEnv = buildSpawnEnv();
    const { env: glmCompatEnv, isGlm } = buildAssistantSpawnEnv();
    const chatEnv = isGlm ? { ...baseEnv, ...glmCompatEnv } : baseEnv;

    const child = spawn('node', [chatScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd(),
      env: chatEnv,
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch Claude CLI:', error.message);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  opencode: async () => {
    const { env: opencodeEnv, isGlm } = buildAssistantSpawnEnv();

    if (isGlm) {
      console.log('🌐 GLM mode active: routing OpenCode CLI through configured GLM endpoint.');
    }

    const child = spawn('opencode', args, {
      stdio: 'inherit',
      cwd: process.cwd(),
      shell: false,
      env: opencodeEnv,
    });

    child.on('error', (error) => {
      console.error('❌ Failed to launch OpenCode CLI:', error.message);
      console.error('   Make sure OpenCode is installed and in your PATH.');
      console.error('   Visit: https://github.com/openchatai/opencode for installation instructions');
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  install: async () => {
    console.log('📦 Installing Agilai globally...\n');

    const child = spawn('npm', ['install', '-g', 'agilai'], {
      stdio: 'inherit',
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        console.log('\n✅ Agilai installed globally!');
        console.log('You can now use: agilai <command>');
      }
      process.exit(code || 0);
    });
  },

  build: async () => {
    console.log('🔨 Building MCP server...\n');

    // Check if running from local install or global/npx
    const localInstall = path.join(process.cwd(), 'node_modules', 'agilai');
    const rootDir = fs.existsSync(localInstall) ? localInstall : path.join(__dirname, '..');

    // The MCP server is already pre-built in dist/, but we'll check TypeScript is available
    const packagedEntryCandidates = [
      path.join(rootDir, 'dist', 'mcp', 'mcp', 'server.js'),
      path.join(rootDir, 'dist', 'mcp', 'server.js'),
    ];
    const resolvedPackagedEntry = packagedEntryCandidates.find((candidate) =>
      fs.existsSync(candidate),
    );

    if (resolvedPackagedEntry) {
      console.log('✅ MCP server already built and ready!');
      console.log(`   Entry point: ${resolvedPackagedEntry}`);
      return;
    }

    // If not found, try to build it
    const child = spawn('npm', ['run', 'build:mcp'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      if (code === 0) {
        const builtEntry = packagedEntryCandidates.find((candidate) =>
          fs.existsSync(candidate),
        );
        console.log('\n✅ MCP server built successfully!');
        if (builtEntry) {
          console.log(`   Entry point: ${builtEntry}`);
        }
      }
      process.exit(code || 0);
    });
  },

  test: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['test'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  validate: async () => {
    const rootDir = path.join(__dirname, '..');
    const child = spawn('npm', ['run', 'validate'], {
      stdio: 'inherit',
      cwd: rootDir,
      shell: true,
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  },

  help: () => {
    // Show help message
    printHelp();
  },
};

const setRuntimeContext = (nextCommand, nextArgs = [], options = {}) => {
  command = nextCommand;
  args = Array.isArray(nextArgs) ? [...nextArgs] : [];
  runtimeOptions = { ...createDefaultRuntimeOptions(), ...(options.runtimeOptions || {}) };
};

const run = (argv = process.argv) => {
  runtimeOptions = createDefaultRuntimeOptions();
  [, , command, ...args] = argv;

  if (!command || command === '--help' || command === '-h') {
    printHelp();
    return Promise.resolve();
  }

  const handler = commands[command];
  if (!handler) {
    console.error(`❌ Unknown command: ${command}`);
    console.log('Run "npx agilai help" for usage information.');
    process.exit(1);
  }

  try {
    const result = handler();
    if (result && typeof result.then === 'function') {
      return result.catch((error) => {
        console.error('❌ Error:', error.message);
        process.exit(1);
      });
    }

    return Promise.resolve(result);
  } catch (error) {
    console.error('❌ Error:', error.message);
    process.exit(1);
    return Promise.resolve();
  }
};

// Run integrity check only when executed directly (not when imported for testing)
// This ensures the CLI validates package integrity at runtime while allowing
// tests to import and mock functions without triggering validation
if (require.main === module) {
  // Skip integrity check during installation to avoid confusing warnings
  const skipIntegrityCheck = process.argv.includes('start') || process.argv.includes('init');
  if (!skipIntegrityCheck) {
    runIntegrityPreflight(packageRoot, { silentOnMatch: true });
  }

  run().catch((error) => {
    console.error('❌ Error:', error.message);
    process.exit(1);
  });
}

module.exports = {
  commands,
  determineAssistant,
  parseAssistantFromArgs,
  printHelp,
  run,
  runIntegrityPreflight,
  setRuntimeContext,
};
