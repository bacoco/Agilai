#!/usr/bin/env node

/**
 * Agilai Orchestrator - Codex Interface
 * Launches Codex CLI with MCP server and orchestrator agent
 */

const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');
const { runIntegrityPreflight } = require('../common/utils/integrity');
const { ensureCliBinary } = require('../common/utils/cli-provisioning');
const { buildAssistantSpawnEnv } = require('../common/utils/assistant-env');

// Get paths
const rootDir = path.join(__dirname, '..');
runIntegrityPreflight(rootDir, { silentOnMatch: true });
const mcpConfigDir = path.join(rootDir, 'mcp');
const newMcpConfigPath = path.join(mcpConfigDir, 'agilai-config.json');
const legacyMcpConfigPath = path.join(mcpConfigDir, 'bmad-config.json');
let mcpConfigPath = newMcpConfigPath;
let usingLegacyMcpConfig = false;
const orchestratorPath = path.join(rootDir, 'agents', 'invisible-orchestrator.md');

// Resolve MCP config path with fallback logic
if (fs.existsSync(newMcpConfigPath)) {
  // Use new config if it exists
  mcpConfigPath = newMcpConfigPath;
  // Warn if both configs exist
  if (fs.existsSync(legacyMcpConfigPath)) {
    console.warn('ℹ️  Found legacy mcp/bmad-config.json alongside new config. You can safely remove the legacy file.');
  }
} else if (fs.existsSync(legacyMcpConfigPath)) {
  // Fall back to legacy config if new config doesn't exist
  // Validate legacy config has the expected structure
  try {
    const legacyConfig = JSON.parse(fs.readFileSync(legacyMcpConfigPath, 'utf8'));
    if (!legacyConfig.mcpServers || typeof legacyConfig.mcpServers !== 'object') {
      throw new Error('Invalid MCP config structure: missing mcpServers object');
    }
    if (Object.keys(legacyConfig.mcpServers).length === 0) {
      throw new Error('Invalid MCP config structure: no servers configured');
    }
    usingLegacyMcpConfig = true;
    mcpConfigPath = legacyMcpConfigPath;
  } catch (error) {
    if (error instanceof SyntaxError) {
      console.error(`Error: Legacy config file ${legacyMcpConfigPath} contains invalid JSON.`);
      console.error(`Parse error: ${error.message}`);
    } else {
      console.error(`Error: Legacy config file ${legacyMcpConfigPath} is invalid or corrupted.`);
      console.error(error.message);
    }
    console.error('Expected mcp/agilai-config.json. Run: npm run build:mcp');
    process.exit(1);
  }
} else {
  // Neither config exists
  console.error('Error: MCP config not found. Expected mcp/agilai-config.json. Run: npm run build:mcp');
  process.exit(1);
}

if (!fs.existsSync(orchestratorPath)) {
  console.error('Error: Orchestrator agent not found');
  process.exit(1);
}

// Read orchestrator content and strip YAML frontmatter
let orchestratorContent = fs.readFileSync(orchestratorPath, 'utf8');

// Remove YAML frontmatter (everything between --- markers)
orchestratorContent = orchestratorContent.replace(/^---\n[\s\S]*?\n---\n/, '');


// Normalise CLI arguments (support `start` as default command)
let userArgs = process.argv.slice(2);
if (userArgs.length > 0 && ['start', 'chat', 'run'].includes(userArgs[0])) {
  userArgs = userArgs.slice(1);
}

async function main() {
  const codexCheck = await ensureCliBinary({
    rootDir,
    binaryName: 'codex',
    friendlyName: 'OpenAI Codex CLI',
    installGuide: {
      autoInstallCommand:
        'npm exec --yes @openai/codex-cli@latest -- codex --help',
      manualSteps: [
        {
          label: 'Homebrew (macOS/Linux)',
          command: 'brew install openai/codex/codex',
        },
        {
          label: 'Manual download & docs',
          url: 'https://platform.openai.com/docs/guides/codex',
        },
      ],
    },
  });

  if (!codexCheck.ok) {
    process.exit(codexCheck.exitCode ?? 1);
  }

  // Codex CLI uses global MCP server configuration, not file-based config
  // We need to ensure the Agilai MCP server is registered
  const mcpServerName = 'agilai';

  // Check if MCP server is already registered
  const checkResult = await new Promise((resolve) => {
    const check = spawn(codexCheck.binaryPath || 'codex', ['mcp', 'list'], {
      stdio: ['ignore', 'pipe', 'pipe'],
    });

    let output = '';
    check.stdout.on('data', (data) => { output += data; });
    check.stderr.on('data', (data) => { output += data; });

    check.on('close', (code) => {
      const isRegistered = output.includes(mcpServerName);
      resolve({ registered: isRegistered, output });
    });
  });

  if (!checkResult.registered) {
    console.log('📡 Registering Agilai MCP server with Codex...');

    // Register the MCP server
    const mcpServerPath = path.join(rootDir, 'dist', 'mcp', 'mcp', 'server.js');
    await new Promise((resolve, reject) => {
      const add = spawn(
        codexCheck.binaryPath || 'codex',
        ['mcp', 'add', mcpServerName, '--', 'node', mcpServerPath],
        { stdio: 'inherit' }
      );

      add.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`Failed to register MCP server (exit code ${code})`));
        }
      });
    });
  }

  // Codex doesn't support --append-system-prompt
  // We prepend the orchestrator instructions to the user's prompt instead
  let initialPrompt = orchestratorContent;
  if (userArgs.length > 0 && !userArgs[0].startsWith('-')) {
    initialPrompt += '\n\n' + userArgs[0];
    userArgs = userArgs.slice(1);
  }

  const codexArgs = [
    initialPrompt,
    ...userArgs,
  ];

  if (usingLegacyMcpConfig) {
    console.warn('⚠️  Using legacy MCP config mcp/bmad-config.json. Note: Codex uses global MCP server configuration.');
  }

  console.log('🎯 Starting Agilai Orchestrator with Codex...');
  console.log('📡 MCP Server: agilai (registered globally)');
  console.log('🤖 Agent: Agilai Orchestrator');
  console.log('💬 Type your project idea to begin!\n');

  const codexBinary = codexCheck.binaryPath || 'codex';
  const { env: codexEnv, isGlm } = buildAssistantSpawnEnv();
  const mergedEnv = { ...process.env, ...codexEnv };

  if (process.env.AGILAI_ASSISTANT_PROVIDER && !('AGILAI_ASSISTANT_PROVIDER' in codexEnv)) {
    mergedEnv.AGILAI_ASSISTANT_PROVIDER = process.env.AGILAI_ASSISTANT_PROVIDER;
  }

  if (process.env.BMAD_ASSISTANT_PROVIDER && !('BMAD_ASSISTANT_PROVIDER' in codexEnv)) {
    mergedEnv.BMAD_ASSISTANT_PROVIDER = process.env.BMAD_ASSISTANT_PROVIDER;
  }

  if (isGlm) {
    console.log('🌐 GLM mode active: routing Codex CLI through configured GLM endpoint.');
  }

  // Launch Codex CLI
  const codex = spawn(codexBinary, codexArgs, {
    stdio: 'inherit',
    shell: false,
    env: mergedEnv,
  });

  codex.on('error', (error) => {
    console.error('Error launching Codex CLI:', error.message);
    console.error(
      '\nCodex CLI is required. See https://platform.openai.com/docs/guides/codex for manual installation steps.'
    );

    process.exit(1);
  });

  codex.on('exit', (code) => {
    process.exit(code || 0);
  });
}

main().catch((error) => {
  console.error('Unexpected error while starting Codex:', error);
  process.exit(1);
});
